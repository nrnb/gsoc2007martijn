Index: trunk/tools/path2java/src/Test.java
===================================================================
--- trunk/tools/path2java/src/Test.java	(revision 0)
+++ trunk/tools/path2java/src/Test.java	(revision 1094)
@@ -0,0 +1,62 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+import junit.framework.TestCase;
+
+class Test extends TestCase
+{
+	void testTokenizer()
+	{			
+		Token t = null;
+		try { t = new Tokenizer ("1").lookAt(); } catch (PathParseException e) { fail ("Unexpected exception"); }
+		assertEquals (t.getFlags(), Token.F_NUMBER | Token.F_NOT_DOUBLE | Token.F_FLAG);
+		assertEquals (t.getDouble(), 1.0, 0.001);
+		assertEquals (t.getBoolean(), true);
+		try { t = new Tokenizer ("0").lookAt(); } catch (PathParseException e) { fail ("Unexpected exception"); }
+		assertEquals (t.getFlags(), Token.F_NUMBER | Token.F_NOT_DOUBLE | Token.F_FLAG);
+		assertEquals (t.getBoolean(), false);
+		try { t = new Tokenizer ("-1").lookAt(); } catch (PathParseException e) { fail ("Unexpected exception"); }
+		assertEquals (t.getFlags(), Token.F_NUMBER | Token.F_NOT_DOUBLE);
+		assertEquals (t.getDouble(), -1, 0.001);
+		try { t = new Tokenizer (".1").lookAt(); } catch (PathParseException e) { fail ("Unexpected exception"); }
+		assertEquals (t.getFlags(), Token.F_NUMBER | Token.F_DOUBLE);
+		assertEquals (t.getDouble(), 0.1, 0.001);
+		try { t = new Tokenizer ("1.").lookAt(); } catch (PathParseException e) { fail ("Unexpected exception"); }
+		assertEquals (t.getFlags(), Token.F_NUMBER | Token.F_DOUBLE);
+		assertEquals (t.getDouble(), 1.0, 0.001);
+		try { t = new Tokenizer ("1e2").lookAt(); } catch (PathParseException e) { fail ("Unexpected exception"); }
+		assertEquals (t.getFlags(), Token.F_NUMBER | Token.F_DOUBLE);
+		assertEquals (t.getDouble(), 100.0, 0.001);
+		try { t = new Tokenizer (".1e2").lookAt(); } catch (PathParseException e) { fail ("Unexpected exception"); }
+		assertEquals (t.getFlags(), Token.F_NUMBER | Token.F_DOUBLE);
+		assertEquals (t.getDouble(), 10.0, 0.001);
+		try { t = new Tokenizer ("1.e2").lookAt(); } catch (PathParseException e) { fail ("Unexpected exception"); }
+		assertEquals (t.getFlags(), Token.F_NUMBER | Token.F_DOUBLE);
+		assertEquals (t.getDouble(), 100.0, 0.001);
+		try { t = new Tokenizer ("1e-2").lookAt(); } catch (PathParseException e) { fail ("Unexpected exception"); }
+		assertEquals (t.getFlags(), Token.F_NUMBER | Token.F_DOUBLE);
+		assertEquals (t.getDouble(), 0.01, 0.001);
+		try { t = new Tokenizer ("-.5").lookAt(); } catch (PathParseException e) { fail ("Unexpected exception"); }
+		assertEquals (t.getFlags(), Token.F_NUMBER | Token.F_DOUBLE);
+		assertEquals (t.getDouble(), -0.5, 0.001);
+		try { t = new Tokenizer ("-5.").lookAt(); } catch (PathParseException e) { fail ("Unexpected exception"); }
+		assertEquals (t.getFlags(), Token.F_NUMBER | Token.F_DOUBLE);
+		assertEquals (t.getDouble(), -5, 0.001);
+		try { t = new Tokenizer ("-.5e-2").lookAt(); } catch (PathParseException e) { fail ("Unexpected exception"); }
+		assertEquals (t.getFlags(), Token.F_NUMBER | Token.F_DOUBLE);
+		assertEquals (t.getDouble(), -0.5e-2, 0.001);			
+	}
+}

Property changes on: trunk/tools/path2java/src/Test.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/tools/path2java/src/StringEmitter.java
===================================================================
--- trunk/tools/path2java/src/StringEmitter.java	(revision 0)
+++ trunk/tools/path2java/src/StringEmitter.java	(revision 1094)
@@ -0,0 +1,164 @@
+import java.awt.geom.Point2D;
+
+class StringEmitter implements Emitter
+{
+	String result = "";
+		
+	boolean fRelative = true;
+    boolean fRound = true;
+	double roundFactor = 1.0;
+	
+	double offX = 0;
+	double offY = 0;
+		
+	void setRelative(boolean value)
+	{
+		fRelative = value;
+	}
+
+	void setRound(boolean value)
+	{
+		fRound = value;
+	}
+
+	void setOffset (double x, double y)
+	{
+		offX = x;
+		offY = y;
+	}
+		
+	public StringEmitter ()
+	{
+	}
+
+	/**
+	   Get the resulting string.
+	   Call after the parsing is done.
+	*/
+	public String getResult()
+	{
+		return result;
+	}
+		
+	public void cleanPoint(Point2D p)
+	{
+		double x = p.getX() + offX;
+		double y = p.getY() + offY;
+			
+		if (fRound)
+		{
+			x = Math.round (x);
+			y = Math.round (y);
+		}
+
+		p.setLocation (x, y);
+	}
+		
+	public void move (Point2D p)
+	{
+		cleanPoint (p);
+		result += "M " + p.getX() + ", " + p.getY() + " ";
+	}
+
+	public void close ()
+	{
+		result += "z ";
+	}
+
+	public void line (Point2D p)
+	{
+		assert (false);
+	}
+
+	public void cubic (Point2D p1, Point2D p2, Point2D p)
+	{
+		cleanPoint (p);
+		cleanPoint (p1);
+		cleanPoint (p2);
+		result += "C " +
+			p1.getX() + ", " + p1.getY() + " " +
+			p2.getX() + ", " + p2.getY() + " " +
+			p.getX() + ", " + p.getY() + " ";
+	}
+
+	public void quad (Point2D p1, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void arc (Point2D r, double rotation, boolean large, boolean sweep, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void smoothCube (Point2D p2, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void smoothQuad (Point2D p)
+	{
+		assert (false);
+	}
+		
+	public void moveRelative (Point2D p)
+	{
+		assert (false);
+	}
+
+	public void lineRelative (Point2D p)
+	{
+		assert (false);
+	}
+
+	public void cubicRelative (Point2D p1, Point2D p2, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void quadRelative (Point2D p1, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void arcRelative (Point2D r, double rotation, boolean large, boolean sweep, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void smoothCubeRelative (Point2D p2, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void smoothQuadRelative (Point2D p)
+	{
+		assert (false);
+	}
+		
+	public void flush()
+	{
+		System.out.println (result);
+	}
+
+	public void horizontal (double x)
+	{
+		assert (false);
+	}
+	
+	public void vertical (double y)
+	{
+		assert (false);
+	}
+	
+	public void horizontalRelative (double x)
+	{
+		assert (false);
+	}
+	
+	public void verticalRelative (double y)
+	{
+		assert (false);
+	}
+
+}

Property changes on: trunk/tools/path2java/src/StringEmitter.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/tools/path2java/src/Token.java
===================================================================
--- trunk/tools/path2java/src/Token.java	(revision 0)
+++ trunk/tools/path2java/src/Token.java	(revision 1094)
@@ -0,0 +1,66 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+class Token
+{
+	static final int F_NUMBER = 0x01; // double, int or flag
+	static final int F_DOUBLE = 0x02; // double, not int
+	static final int F_NOT_DOUBLE = 0x04; // int or flag, not double
+	static final int F_FLAG = 0x08; // flag, not int or double
+	static final int F_COMMAND = 0x10; // command
+	static final int F_WHITESPACE_OR_COMMA = 0x20; // whitespace or comma
+	static final int F_COMMA = 0x40; // comma, not whitespace
+	static final int F_WHITESPACE = 0x80; // whitespace, not comma
+	static final int F_END = 0x100;
+		   
+	private int flags = 0;
+	private double doubleValue = 0.0;
+	private char command = ' ';
+
+	/**
+	   constructor for number tokens
+	*/
+	Token (int _flags, double _value)
+	{
+		assert ((_flags & (F_NUMBER | F_DOUBLE | F_NOT_DOUBLE | F_FLAG)) == _flags);
+		doubleValue = _value;
+		flags = _flags;
+	}
+
+	/**
+	   constructor for command tokens
+	*/
+	Token (char _command)
+	{
+		flags = F_COMMAND;
+		command = _command; 
+	}
+
+	/**
+	   constructor for whitespace, comma or end tokens
+	*/
+	Token (int _flags)
+	{
+		assert ((_flags & (F_COMMA | F_WHITESPACE_OR_COMMA | F_WHITESPACE | F_END)) == _flags);
+		flags = _flags;
+	}
+
+	int getFlags () { return flags; }
+	double getDouble () { return doubleValue; }
+	boolean getBoolean () { return (Math.round (doubleValue) == 1); }
+	char getCommand () { return command; }
+	boolean testFlag (int value) { return ((flags & value) > 0); }
+}

Property changes on: trunk/tools/path2java/src/Token.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/tools/path2java/src/Main.java
===================================================================
--- trunk/tools/path2java/src/Main.java	(revision 0)
+++ trunk/tools/path2java/src/Main.java	(revision 1094)
@@ -0,0 +1,195 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+import javax.swing.*;
+import java.awt.*;
+import java.awt.geom.*;
+import java.io.*;
+
+class Main extends JPanel
+{
+	static final String KITTY =
+		"M 487.28125,410.34375 C 467.92059,410.36864 439.49832,431.6392 413.1875,467.84375 C 396.60478,461.52191 378.68892,458.0625 360,458.0625 C 338.39321,458.0625 317.83036,462.70264 299.15625,471.03125 C 259.62049,420.76245 215.60001,399.09165 199.3125,422.71875 C 185.00239,443.47738 196.69397,492.53451 225.3125,540.03125 C 212.84087,563.12076 205.71875,589.7321 205.71875,618.0625 C 205.71875,706.3825 274.83428,778.0625 360,778.0625 C 445.16572,778.0625 514.28127,706.3825 514.28125,618.0625 C 514.28125,584.03715 504.01389,552.50141 486.53125,526.5625 C 508.72684,482.55443 517.03884,439.11209 504.84375,419.90625 C 500.7162,413.40584 494.65755,410.33427 487.28125,410.34375 z M 325.12425,640.06448 C 353.69568,682.92163 359.40997,680.06448 359.40997,680.06448 L 385.12425,642.92163 L 325.12425,640.06448 z M 310.40619,626.076 L 264.46956,611.56795M 310.41802,648.94498 L 273.02916,645.84183M 310.40463,660.14094 L 275.8997,683.2173M 399.2988,619.52317 L 445.23543,605.01512M 399.28697,642.39215 L 436.67583,639.289M 399.30036,653.58811 L 433.80529,676.66447M 295.58816,549.02042 C 293.63331,554.51846 291.42896,562.73008 291.68191,571.45792 C 291.8879,578.56582 293.69499,584.69073 295.58816,589.20792 C 298.00617,589.8241 300.42704,590.20424 302.80691,590.42667 C 304.75417,584.84073 306.95769,576.5828 306.71316,568.14542 C 306.53582,562.02648 305.16028,556.58171 303.58816,552.27042 C 301.02826,550.84095 298.31987,549.79095 295.58816,549.02042 z M 326.53799,589.22837 C 326.66283,589.18334 302.92317,596.23658 286.30056,585.52101 C 269.67794,574.80543 266.52585,550.76252 266.31111,550.40381 C 266.0216,549.9202 289.92592,543.39559 306.54855,554.11117 C 323.17116,564.82674 326.644,590.3832 326.53799,589.22837 z M 415.71707,548.19116 C 417.67192,553.6892 419.87627,561.90082 419.62332,570.62866 C 419.41733,577.73656 417.61024,583.86147 415.71707,588.37866 C 413.29906,588.99484 410.87819,589.37498 408.49832,589.59741 C 406.55106,584.01147 404.34754,575.75354 404.59207,567.31616 C 404.76941,561.19722 406.14495,555.75245 407.71707,551.44116 C 410.27697,550.01169 412.98536,548.96169 415.71707,548.19116 z M 384.76724,588.39911 C 384.6424,588.35408 408.38206,595.40732 425.00467,584.69175 C 441.62729,573.97617 444.77938,549.93326 444.99412,549.57455 C 445.28363,549.09094 421.37931,542.56633 404.75668,553.28191 C 388.13407,563.99748 384.66123,589.55394 384.76724,588.39911 z ";
+	static final String SIMPLIFIED[] =
+	{
+		"M 227.0, 139.0 C 227.0, 155.0 220.0, 169.0 211.0, 169.0 C 202.0, 169.0 194.0, 155.0 194.0, 139.0 C 194.0, 123.0 202.0, 109.0 211.0, 109.0 C 220.0, 109.0 227.0, 123.0 227.0, 139.0 z ",
+		"M 220.0, 94.0 C 214.0, 112.0 204.0, 123.0 197.0, 119.0 C 191.0, 115.0 190.0, 97.0 196.0, 80.0 C 202.0, 62.0 212.0, 51.0 219.0, 55.0 C 225.0, 59.0 226.0, 77.0 220.0, 94.0 z M 240.0, 63.0 C 225.0, 116.0 203.0, 156.0 189.0, 152.0 C 176.0, 147.0 177.0, 101.0 192.0, 47.0 C 207.0, -6.0 230.0, -46.0 243.0, -41.0 C 256.0, -37.0 255.0, 10.0 240.0, 63.0 z ",
+		"M 220.0, 94.0 C 214.0, 112.0 204.0, 123.0 197.0, 119.0 C 191.0, 115.0 190.0, 97.0 196.0, 80.0 C 202.0, 62.0 212.0, 51.0 219.0, 55.0 C 225.0, 59.0 226.0, 77.0 220.0, 94.0 z M 240.0, 63.0 C 225.0, 116.0 203.0, 156.0 189.0, 152.0 C 176.0, 147.0 177.0, 101.0 192.0, 47.0 C 207.0, -6.0 230.0, -46.0 243.0, -41.0 C 256.0, -37.0 255.0, 10.0 240.0, 63.0 z "
+	};
+
+	static final String PATH[] =
+	{
+		"M 226.8463,139.00732 C 226.8463,155.48353 219.58722,168.85552 " +
+        "210.64299,168.85552 C 201.69876,168.85552 194.43968,155.48353 " +
+        "194.43968,139.00732 C 194.43968,122.53112 201.69876,109.15913 " +
+        "210.64299,109.15913 C 219.58722,109.15913 226.8463,122.53112 " +
+        "226.8463,139.00732 z",
+
+		"M 219.8743,994.27966 C 213.94517,1011.9431 203.82434,1022.9856 " +
+        "197.28316,1018.9282 C 190.74198,1014.8708 190.24524,997.24235 " +
+        "196.17437,979.57895 C 202.10349,961.91556 212.22432,950.873 " +
+        "218.7655,954.9304 C 225.30669,958.9878 225.80343,976.61627 " +
+        "219.8743,994.27966 z M 240.08057,962.90051 C " +
+        "225.37358,1016.1844 202.712,1055.9778 189.49669,1051.725 C " +
+        "176.28138,1047.4723 177.49203,1000.7759 192.19902,947.492 C " +
+        "206.90601,894.20812 229.56758,854.41473 242.78289,858.66748 C " +
+        "255.9982,862.92023 254.78756,909.61663 240.08057,962.90051 z",
+
+		"M 462.19521,1121.3044 C 462.19521,1132.4343 452.83856,1141.4672 " +
+        "441.30983,1141.4672 C 429.7811,1141.4672 420.42446,1132.4343 " +
+        "420.42446,1121.3044 C 420.42446,1110.1746 429.7811,1101.1417 " +
+        "441.30983,1101.1417 C 452.83856,1101.1417 462.19521,1110.1746 " +
+        "462.19521,1121.3044 z M 464.99209,1121.3044 C " +
+        "464.99209,1133.933 454.38246,1144.1822 441.30988,1144.1822 C " +
+        "428.2373,1144.1822 417.62766,1133.933 417.62766,1121.3044 C " +
+        "417.62766,1108.6758 428.2373,1098.4266 441.30988,1098.4266 C " +
+        "454.38246,1098.4266 464.99209,1108.6758 464.99209,1121.3044 z",
+
+		"M 533.85634 676.2749 A 40.081867 188.47005 0 1 1 453.69261,676.2749 A " +
+        "40.081867 188.47005 0 1 1 533.85634 676.2749 z",
+
+		"M 554.58627,1033.4711 C 545.84018,1006.4858 540.3078,951.48969 " +
+        "540.3078,907.75011 C 540.3078,865.14636 546.15128,800.64477 " +
+        "554.85453,772.6508 C 555.2037,764.15253 565.93866,752.66995 " +
+        "578.05172,752.66995 C 589.35968,752.66995 599.6922,762.53754 " +
+        "599.6922,775.19331 C 598.99356,787.91976 589.60241,798.32872 " +
+        "572.15745,796.12265 C 563.36386,822.66692 562.53878,854.18071 " +
+        "562.53878,896.29383 C 562.53878,939.52962 563.16536,979.27862 " +
+        "572.16222,1006.1756 C 589.89243,1006.2335 599.5934,1017.4158 " +
+        "599.5934,1030.4534 C 599.5934,1042.2798 585.80704,1052.1547 " +
+        "576.2186,1052.0536 C 566.61166,1051.9563 554.98881,1040.8563 " +
+        "554.58627,1033.4711 z"
+	};
+	
+	class PathPane extends JPanel
+	{
+		int xco, yco;
+		
+		public void paintPath (Graphics2D target, String pathString)
+		{
+			try
+			{
+				ShapeEmitter em = new ShapeEmitter();
+				Parser p = new Parser(pathString, em);
+				p.parse ();
+				Shape sh = em.getShape();
+			    Rectangle r = sh.getBounds();
+				AffineTransform x = AffineTransform.getTranslateInstance (-r.x + xco, -r.y + yco);
+				sh = x.createTransformedShape (sh);
+				target.draw (sh);
+				xco += r.width;
+			}
+			catch (PathParseException e)
+			{
+				e.printStackTrace();
+			}
+		}
+		
+		public void paintComponent (Graphics g)
+		{
+			xco = 0;
+			yco = 0;
+			super.paintComponent(g);
+			Graphics2D g2d = (Graphics2D)g;
+			ShapeEmitter em = new ShapeEmitter();
+			g2d.setColor (Color.BLACK);
+			g2d.setStroke (new BasicStroke (2));
+			paintPath (g2d, PATH[0]);
+			paintPath (g2d, PATH[1]);
+			paintPath (g2d, PATH[2]);
+			paintPath (g2d, PATH[3]);
+			paintPath (g2d, PATH[4]);
+		}
+	}
+
+	public Main()
+	{
+		super ();
+
+		JPanel drawingPane = new PathPane();
+		drawingPane.setBackground (Color.WHITE);
+		drawingPane.setSize (1000, 1000);
+
+		JScrollPane scroller = new JScrollPane(drawingPane);
+		scroller.setPreferredSize (new Dimension (800, 600));
+		
+		add (scroller);
+	}
+
+	public void printPath(String pathString)
+	{
+		try
+		{
+			ShapeEmitter em = new ShapeEmitter();
+			Parser p = new Parser(pathString, em);
+			p.parse ();
+			Shape sh = em.getShape();
+			Rectangle r = sh.getBounds();
+			JavaEmitter em2 = new JavaEmitter (new PrintWriter (System.out), null);
+			em2.setOffset (r.x, r.y);
+			p = new Parser(pathString, em2);
+			p.parse ();
+		}
+		catch (PathParseException pe)
+		{
+			pe.printStackTrace();
+		}
+	}
+	
+	public void run()
+	{
+// 		printPath (PATH[0]);
+// 		printPath (PATH[1]);
+// 		printPath (PATH[2]);
+// 		printPath (PATH[3]);
+// 		printPath (PATH[4]);
+		printPath (KITTY);
+	}
+
+	public static void printUsage()
+	{
+		System.out.println (
+			"path2visio\n" +
+			"Creates a series of java statements based on an svg path/p attribute.\n\n" +
+			"Usage:\n"+
+			"    path2visio \"PATH DATA\"\n");		
+	}
+	
+	public static void main(String[] argv)
+	{
+		if (argv.length > 0)
+		{
+			Main m = new Main();
+			m.printPath(argv[0]);
+		}
+		else
+		{
+			printUsage();
+		}
+/*
+		JFrame frame = new JFrame("Path Parser Demo");
+		frame.setSize (1000, 1000);
+
+		JComponent newContentPane = new Main();
+		newContentPane.setOpaque(true);
+		frame.setContentPane (newContentPane);
+
+		frame.pack();
+		frame.setVisible (true);
+*/
+    }
+	
+}
\ No newline at end of file

Property changes on: trunk/tools/path2java/src/Main.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/tools/path2java/src/PathParseException.java
===================================================================
--- trunk/tools/path2java/src/PathParseException.java	(revision 0)
+++ trunk/tools/path2java/src/PathParseException.java	(revision 1094)
@@ -0,0 +1,23 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+class PathParseException extends Exception
+{
+	PathParseException(String s)
+	{
+		super (s);
+	}
+}

Property changes on: trunk/tools/path2java/src/PathParseException.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/tools/path2java/src/Emitter.java
===================================================================
--- trunk/tools/path2java/src/Emitter.java	(revision 0)
+++ trunk/tools/path2java/src/Emitter.java	(revision 1094)
@@ -0,0 +1,46 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+
+import java.awt.geom.Point2D;
+
+interface Emitter
+{
+	public void move (Point2D p);
+	public void close ();
+	public void line (Point2D p);
+	public void cubic (Point2D p1, Point2D p2, Point2D p);
+	public void quad (Point2D p1, Point2D p);
+	public void arc (Point2D r, double rotation, boolean large, boolean sweep, Point2D p);
+	public void smoothCube (Point2D p2, Point2D p);
+	public void smoothQuad (Point2D p);
+	
+	public void horizontal (double x);
+	public void vertical (double y);
+	
+	public void moveRelative (Point2D p);
+	public void lineRelative (Point2D p);
+	public void cubicRelative (Point2D p1, Point2D p2, Point2D p);
+	public void quadRelative (Point2D p1, Point2D p);
+	public void arcRelative (Point2D r, double rotation, boolean large, boolean sweep, Point2D p);
+	public void smoothCubeRelative (Point2D p2, Point2D p);
+	public void smoothQuadRelative (Point2D p);
+	
+	public void horizontalRelative (double x);
+	public void verticalRelative (double y);
+	
+	public void flush();
+}	

Property changes on: trunk/tools/path2java/src/Emitter.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/tools/path2java/src/ShapeEmitter.java
===================================================================
--- trunk/tools/path2java/src/ShapeEmitter.java	(revision 0)
+++ trunk/tools/path2java/src/ShapeEmitter.java	(revision 1094)
@@ -0,0 +1,162 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+import java.awt.geom.Point2D;
+import java.awt.geom.GeneralPath;
+import java.awt.Shape;
+
+class ShapeEmitter implements Emitter
+{
+	GeneralPath path;
+	Point2D pen;
+	Point2D start;
+
+	/**
+	   get the resulting shape. Call afterwards
+	 */
+	public Shape getShape()
+	{
+		return path;
+	}
+		
+	ShapeEmitter ()
+	{
+		path = new GeneralPath();
+		pen = new Point2D.Double (0,0);
+	}
+		
+	public void move (Point2D p)
+	{			
+		path.moveTo ((float)p.getX(), (float)p.getY());
+		pen = p;
+		start = p;
+	}
+		
+	public void close ()
+	{
+		path.closePath();
+		pen = start;
+	}
+
+	public void line (Point2D p)
+	{
+		path.lineTo ((float)p.getX(), (float)p.getY());
+		pen = p;
+	}
+
+	public void cubic (Point2D p1, Point2D p2, Point2D p)
+	{
+		path.curveTo (
+			(float)p1.getX(), (float)p1.getY(),
+			(float)p2.getX(), (float)p2.getY(),
+			(float)p.getX(), (float)p.getY()
+			);
+		pen = p;
+	}
+
+	public void quad (Point2D p1, Point2D p)
+	{
+		path.quadTo ((float)p1.getX(), (float)p1.getY(), (float)p.getX(), (float)p.getY());
+		pen = p;
+	}
+
+	public void arc (Point2D r, double rotation, boolean large, boolean sweep, Point2D p)
+	{
+		assert (false);
+		/*
+		  Arc2D a = new Arc2D.Double ();
+		a.setStartPoint (pen);
+		a.setWidth (r.getX() * 2);
+		a.setHeight (r.getY() * 2);
+		
+		// ration is ignored, Arc2D can't handle it.
+		path.append(a.)
+			pen = p;
+		*/
+	}
+
+	public void smoothCube (Point2D p2, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void smoothQuad (Point2D p)
+	{
+		assert (false);
+	}
+		
+	public void moveRelative (Point2D p)
+	{			
+		path.moveTo ((float)(pen.getX() + p.getX()), (float)(pen.getY() + p.getY()));
+		pen.setLocation (pen.getX() + p.getX(), pen.getY() + p.getY());
+		start = pen;
+	}
+
+	public void lineRelative (Point2D p)
+	{
+		assert (false);
+	}
+
+	public void cubicRelative (Point2D p1, Point2D p2, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void quadRelative (Point2D p1, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void arcRelative (Point2D r, double rotation, boolean large, boolean sweep, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void smoothCubeRelative (Point2D p2, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void smoothQuadRelative (Point2D p)
+	{
+		assert (false);
+	}
+		
+	public void flush()
+	{
+	}
+
+	public void horizontal (double x)
+	{
+		assert (false);
+	}
+	
+	public void vertical (double y)
+	{
+		assert (false);
+	}
+	
+	public void horizontalRelative (double x)
+	{
+		assert (false);
+	}
+	
+	public void verticalRelative (double y)
+	{
+		assert (false);
+	}
+
+}

Property changes on: trunk/tools/path2java/src/ShapeEmitter.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/tools/path2java/src/Tokenizer.java
===================================================================
--- trunk/tools/path2java/src/Tokenizer.java	(revision 0)
+++ trunk/tools/path2java/src/Tokenizer.java	(revision 1094)
@@ -0,0 +1,124 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+import java.util.regex.*;
+
+class Tokenizer
+{
+	private String original;
+	private String s; 
+	private String newS; // new string after token is eaten
+	Token nextToken;
+			
+	public Tokenizer (String _s) throws PathParseException
+	{
+		s = _s;
+		original = _s;
+		nextToken = tokenize();
+	}
+
+	/**
+	   returns the next token and moves ahead in the string
+	*/
+	public Token eat () throws PathParseException
+	{
+		Token result = nextToken;
+		s = newS;
+		nextToken = tokenize();
+		return result;
+	}
+
+	/**
+	   Returns the next token without moving ahead in the string
+	*/
+	public Token lookAt ()
+	{
+		return nextToken;
+	}
+			
+	/**
+	   returns the upcoming token, while setting newS to the string after the token.
+	*/
+	private Token tokenize () throws PathParseException
+	{
+		String VALID_COMMANDS = "MmZzLlHhVvCcSsQqTtAa";
+				
+		Pattern comma_wsp = Pattern.compile ("\\s*,\\s*");
+		Pattern wsp = Pattern.compile ("\\s+");
+		Pattern float_with_exponent = Pattern.compile ("[+-]?(\\.\\d+|\\d+\\.?\\d*)([eE][+-]?\\d+)");
+		Pattern float_without_exponent = Pattern.compile ("[+-]?(\\d+\\.\\d*|\\d*\\.\\d+)");
+		Pattern int_constant = Pattern.compile ("[+-]?\\d+");
+		Pattern command = Pattern.compile ("[" + VALID_COMMANDS + "]");
+
+		if (s == null || s.equals (""))
+		{
+			return new Token (Token.F_END);
+		}
+			
+		Matcher m = comma_wsp.matcher (s);
+		if (m.lookingAt())
+		{
+			newS = s.substring (m.end());
+			return (new Token (Token.F_WHITESPACE_OR_COMMA | Token.F_COMMA));
+		}
+		m.usePattern (wsp);
+		if (m.lookingAt())
+		{
+			newS = s.substring (m.end());
+			return (new Token (Token.F_WHITESPACE_OR_COMMA | Token.F_WHITESPACE));
+		}
+		m.usePattern (float_without_exponent);
+		if (m.lookingAt())
+		{
+			newS = s.substring (m.end());
+			return new Token (
+				Token.F_NUMBER | Token.F_DOUBLE,
+				Double.parseDouble(m.group())
+				);
+		}
+			
+		m.usePattern (float_with_exponent);
+		if (m.lookingAt())
+		{
+			newS = s.substring (m.end());
+			return new Token (
+				Token.F_NUMBER | Token.F_DOUBLE,
+				Double.parseDouble(m.group())
+				);
+		}
+
+		m.usePattern (int_constant);
+		if (m.lookingAt())
+		{
+			newS = s.substring (m.end());
+			int value = Integer.parseInt (m.group());
+			return new Token (
+				Token.F_NUMBER | Token.F_NOT_DOUBLE | ((value == 0 || value == 1) ? Token.F_FLAG : 0),
+				value
+				);
+		}
+
+		m.usePattern(command);
+		if (m.lookingAt())
+		{
+			newS = s.substring (m.end());
+			return new Token (m.group().charAt(0));
+		}
+
+		throw new PathParseException ("Parse error: unknown Token");
+	}
+			
+}

Property changes on: trunk/tools/path2java/src/Tokenizer.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/tools/path2java/src/JavaEmitter.java
===================================================================
--- trunk/tools/path2java/src/JavaEmitter.java	(revision 0)
+++ trunk/tools/path2java/src/JavaEmitter.java	(revision 1094)
@@ -0,0 +1,230 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+import java.io.PrintWriter;
+import java.io.IOException;
+import java.awt.geom.Point2D;
+
+class JavaEmitter implements Emitter
+{
+	PrintWriter target;
+	String name;
+
+	Point2D pen;
+	Point2D start;
+
+	double offX = 0;
+	double offY = 0;
+
+	boolean fRelative = false;
+    boolean fRound = true;
+
+	String format = "%.2ff";
+	
+	public void setRelative(boolean value)
+	{
+		fRelative = value;
+	}
+
+	public void setRound(boolean value)
+	{
+		fRound = value;
+	}
+
+	public void setOffset (double x, double y)
+	{
+		offX = x;
+		offY = y;
+	}
+
+	public void setFormat (String value)
+	{
+		format = value;
+	}
+
+	private void printAbsolutePoint (Point2D p)
+	{
+		double x = p.getX() + offX;
+		double y = p.getY() + offY;
+
+		if (fRound)
+		{
+			target.printf (format, x);
+			target.print (", ");
+			target.printf (format, y);
+		}
+		else
+		{
+			target.print (x + ", " + y);
+		}
+	}
+
+	private void printRelativePoint (Point2D p)
+	{
+		double x = p.getX() + pen.getX();
+		double y = p.getY() + pen.getY();
+
+		if (fRound)
+		{
+			target.printf (format, x);
+			target.print (", ");
+			target.printf (format, y);
+		}
+		else
+		{
+			target.print (x + ", " + y);
+		}
+	}
+	
+	public JavaEmitter (PrintWriter w, String _name)
+	{
+		assert (w != null);
+		target = w;
+		name = _name;
+		target.println ("GeneralPath path = new GeneralPath();");
+		Point2D.Double pen = new Point2D.Double(0,0);
+	}
+
+	public void move (Point2D p)
+	{
+		target.print ("path.moveTo (");
+		printAbsolutePoint (p);
+		target.println (");");
+		
+		pen = p;
+		start = p;
+	}
+
+	public void close ()
+	{
+		target.println ("path.closePath();");
+		pen = start;
+	}
+
+	public void line (Point2D p)
+	{
+		target.print ("path.lineTo (");
+		printAbsolutePoint (p);
+		target.println (");");
+
+		pen = p;
+	}
+
+	public void cubic (Point2D p1, Point2D p2, Point2D p)
+	{
+		target.print ("path.curveTo (");
+		printAbsolutePoint (p1);
+		target.print (", ");
+		printAbsolutePoint (p2);
+		target.print (", ");
+		printAbsolutePoint (p);
+		target.println (");");
+
+		pen = p;
+	}
+
+	public void quad (Point2D p1, Point2D p)
+	{
+		target.print ("path.quadTo (");
+		printAbsolutePoint (p1);
+		target.print (", ");
+		printAbsolutePoint (p);
+		target.println (");");
+		pen = p;
+	}
+
+	public void arc (Point2D r, double rotation, boolean large, boolean sweep, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void smoothCube (Point2D p2, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void smoothQuad (Point2D p)
+	{
+		assert (false);
+	}
+		
+	public void moveRelative (Point2D p)
+	{
+		target.print ("path.moveTo (");
+		printRelativePoint (p);
+		target.println (");");
+		pen.setLocation (pen.getX() + p.getX(), pen.getY() + p.getY());
+		start = pen;
+			
+	}
+
+	public void lineRelative (Point2D p)
+	{
+		assert (false);
+	}
+
+	public void cubicRelative (Point2D p1, Point2D p2, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void quadRelative (Point2D p1, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void arcRelative (Point2D r, double rotation, boolean large, boolean sweep, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void smoothCubeRelative (Point2D p2, Point2D p)
+	{
+		assert (false);
+	}
+
+	public void smoothQuadRelative (Point2D p)
+	{
+		assert (false);
+	}
+		
+	public void flush()
+	{
+		target.println ("return path;");
+		target.flush();
+	}
+
+	public void horizontal (double x)
+	{
+		assert (false);
+	}
+	
+	public void vertical (double y)
+	{
+		assert (false);
+	}
+	
+	public void horizontalRelative (double x)
+	{
+		assert (false);
+	}
+	
+	public void verticalRelative (double y)
+	{
+		assert (false);
+	}
+
+}

Property changes on: trunk/tools/path2java/src/JavaEmitter.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/tools/path2java/src/Parser.java
===================================================================
--- trunk/tools/path2java/src/Parser.java	(revision 0)
+++ trunk/tools/path2java/src/Parser.java	(revision 1094)
@@ -0,0 +1,183 @@
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+import java.awt.geom.Point2D;
+
+class Parser
+{
+	private Tokenizer tokenizer;
+	private Emitter emitter;
+
+	Parser (String path, Emitter _emitter) throws PathParseException
+	{
+		tokenizer = new Tokenizer (path);
+		emitter = _emitter;
+	}
+
+	/**
+	   only public method: parses a string and emits symbols to the emitter.
+	*/
+	public void parse () throws PathParseException
+	{
+		while (!tokenizer.lookAt().testFlag (Token.F_END))
+		{
+			eatExpression ();
+		}
+		emitter.flush();
+	}
+
+	/**
+	   if the next token is whitespace, eat it
+	   otherwise do nothing
+	*/
+	void eatWhitespace () throws PathParseException
+	{			
+		if (tokenizer.lookAt().testFlag (Token.F_WHITESPACE))
+		{
+			tokenizer.eat();
+		}
+	}
+
+	boolean eatFlag() throws PathParseException
+	{
+		eatWhitespace();			
+		Token t = tokenizer.eat();
+		if (!t.testFlag(Token.F_FLAG)) { throw new PathParseException("Flag expected"); }
+		eatWhitespace();	
+		return (t.getBoolean());
+	}
+		
+	double eatNumber() throws PathParseException
+	{
+		eatWhitespace();
+		Token t = tokenizer.eat();
+		if (!t.testFlag(Token.F_NUMBER)) { throw new PathParseException("Number expected"); }
+		eatWhitespace();
+		return t.getDouble();
+	}
+		
+	Point2D eatCoords() throws PathParseException
+	{
+		eatWhitespace();
+		double x, y;
+		if (tokenizer.lookAt().testFlag(Token.F_NUMBER))
+		{
+			x = tokenizer.eat().getDouble();
+		}
+		else
+		{
+			throw new PathParseException ("Number expected");
+		}
+		if (tokenizer.lookAt().testFlag(Token.F_WHITESPACE_OR_COMMA))
+		{
+			tokenizer.eat();
+		}
+		else
+		{
+			throw new PathParseException ("Whitespace and/or comma expected");
+		}
+		if (tokenizer.lookAt().testFlag(Token.F_NUMBER))
+		{
+			y = tokenizer.eat().getDouble();
+		}
+		else
+		{
+			throw new PathParseException ("Number expected");
+		}
+		eatWhitespace();
+		return new Point2D.Double(x, y);
+	}
+		
+	void eatExpression () throws PathParseException
+	{
+		eatWhitespace();
+		Token t = tokenizer.eat();
+		if (t.testFlag(Token.F_END)) { return; } // the end
+		if (!t.testFlag(Token.F_COMMAND))
+		{
+			throw new PathParseException ("Command, whitespace or end expected");
+		}
+		char command = t.getCommand();
+		if (command == 'z' || command == 'Z')
+		{
+			emitter.close();
+			return;
+		}
+		do
+		{
+			switch (command)
+			{
+			case 'M': 
+				emitter.move (eatCoords());
+				break;
+			case 'm':
+				emitter.moveRelative (eatCoords());
+				break;
+			case 'L':
+				emitter.line (eatCoords());
+				break;
+			case 'l':
+				emitter.lineRelative (eatCoords());
+				break;
+			case 'H': 
+				emitter.horizontal (eatNumber());
+				break;
+			case 'h':
+				emitter.horizontalRelative (eatNumber());
+				break;
+			case 'V':
+				emitter.vertical (eatNumber());
+				break;
+			case 'v':
+				emitter.verticalRelative (eatNumber());
+				break;
+			case 'C':
+				emitter.cubic (eatCoords(), eatCoords(), eatCoords());
+				break;
+			case 'c':
+				emitter.cubicRelative (eatCoords(), eatCoords(), eatCoords());
+				break;
+			case 'S':
+				emitter.smoothCube (eatCoords(), eatCoords());
+				break;
+			case 's':
+				emitter.smoothCubeRelative (eatCoords(), eatCoords());
+				break;
+			case 'Q':
+				emitter.quad (eatCoords(), eatCoords());
+				break;
+			case 'q':
+				emitter.quadRelative (eatCoords(), eatCoords());
+				break;
+			case 'T':
+				emitter.smoothQuad (eatCoords());
+				break;
+			case 't':
+				emitter.smoothQuadRelative (eatCoords());
+				break;
+			case 'A':
+				emitter.arc (eatCoords(), eatNumber(), eatFlag(), eatFlag(), eatCoords());
+				break;
+			case 'a':
+				emitter.arcRelative (eatCoords(), eatNumber(), eatFlag(), eatFlag(), eatCoords());
+				break;
+			default:
+				throw new PathParseException("Unknown command: '" + t.getCommand() + "'");
+			}
+		}			
+		while (tokenizer.lookAt().testFlag (Token.F_NUMBER));
+	}
+}

Property changes on: trunk/tools/path2java/src/Parser.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/tools/path2java/path2java.sh
===================================================================
--- trunk/tools/path2java/path2java.sh	(revision 0)
+++ trunk/tools/path2java/path2java.sh	(revision 1094)
@@ -0,0 +1,2 @@
+#!/bin/sh
+java -ea -cp build Main "$1"
\ No newline at end of file

Property changes on: trunk/tools/path2java/path2java.sh
___________________________________________________________________
Name: svn:eol-style
   + native
Name: svn:executable
   + *

Index: trunk/tools/path2java/build.xml
===================================================================
--- trunk/tools/path2java/build.xml	(revision 0)
+++ trunk/tools/path2java/build.xml	(revision 1094)
@@ -0,0 +1,27 @@
+<?xml version="1.0"?>
+<project name="Path2Java" default="compile" basedir=".">	
+	<property name="src.dir" value="src"/>
+	<property name="build.dir" value="build"/>
+    <path id="project.class.path">
+		<pathelement location="${build.dir}"/>
+		<fileset dir="../../lib">
+		        <include name="junit.jar"/>
+		</fileset>
+	</path>
+
+	<target name="prepare">
+		<mkdir dir="${build.dir}"/>
+	</target>
+	
+	<target name="clean" description="Remove all generated files.">
+		<delete dir="${build.dir}"/>
+		<delete dir="${apidoc.dir}"/>
+	</target>
+	
+	<target name="compile" depends="prepare" description="Compile all sources">
+		<javac srcdir="${src.dir}" debug="true"	destdir="${build.dir}">
+			<classpath refid="project.class.path"/>
+		</javac>
+	</target>
+	
+</project>
