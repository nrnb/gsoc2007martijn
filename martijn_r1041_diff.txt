Index: trunk/src/wikipathways/org/pathvisio/Globals.java
===================================================================
--- trunk/src/wikipathways/org/pathvisio/Globals.java	(revision 1040)
+++ trunk/src/wikipathways/org/pathvisio/Globals.java	(revision 1041)
@@ -1,31 +1,31 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio;
-
-/**
- * This class is mainly intended for globals that differ between v1 and v2!
- * 
- * @author martijn.vaniersel
- *
- */
-public class Globals {
-	public static final String APPLICATION_NAME = "PathVisio";
-	public static final String APPLICATION_VERSION_NAME = "PathVisio - WikiPathways";
-	public static final String HELP_URL = "http://wiki.bigcat.unimaas.nl/pathvisio/Help";
-	// for inclusion in certain error messages.
-	public static final String DEVELOPER_EMAIL = "thomas.kelder@bigcat.unimaas.nl"; 
-}
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio;
+
+/**
+ * This class is mainly intended for globals that differ between v1 and v2!
+ * 
+ * @author martijn.vaniersel
+ *
+ */
+public class Globals {
+	public static final String APPLICATION_NAME = "PathVisio";
+	public static final String APPLICATION_VERSION_NAME = "PathVisio - WikiPathways";
+	public static final String HELP_URL = "http://wiki.bigcat.unimaas.nl/pathvisio/Help";
+	// for inclusion in certain error messages.
+	public static final String DEVELOPER_EMAIL = "thomas.kelder@bigcat.unimaas.nl"; 
+}

Property changes on: trunk/src/wikipathways/org/pathvisio/Globals.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/v1/org/pathvisio/Globals.java
===================================================================
--- trunk/src/v1/org/pathvisio/Globals.java	(revision 1040)
+++ trunk/src/v1/org/pathvisio/Globals.java	(revision 1041)
@@ -1,32 +1,32 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio;
-
-/**
- * This class is mainly intended for globals that differ between v1 and v2!
- * 
- * @author martijn.vaniersel
- *
- */
-public class Globals {
-	public static final String APPLICATION_NAME = "PathVisio";
-	public static final String APPLICATION_VERSION_NAME = "PathVisio 1.0 release candidate 2";
-	public static final String HELP_URL = "http://wiki.bigcat.unimaas.nl/pathvisio/Help";
-	// for inclusion in certain error messages.
-	public static final String DEVELOPER_EMAIL = "martijn.vaniersel@bigcat.unimaas.nl"; 
-	public static final boolean fUseExperimentalFeatures = false;
-}
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio;
+
+/**
+ * This class is mainly intended for globals that differ between v1 and v2!
+ * 
+ * @author martijn.vaniersel
+ *
+ */
+public class Globals {
+	public static final String APPLICATION_NAME = "PathVisio";
+	public static final String APPLICATION_VERSION_NAME = "PathVisio 1.0 release candidate 2";
+	public static final String HELP_URL = "http://wiki.bigcat.unimaas.nl/pathvisio/Help";
+	// for inclusion in certain error messages.
+	public static final String DEVELOPER_EMAIL = "martijn.vaniersel@bigcat.unimaas.nl"; 
+	public static final boolean fUseExperimentalFeatures = false;
+}

Property changes on: trunk/src/v1/org/pathvisio/Globals.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swing/com/mammothsoftware/frwk/ddb/RolloverButton.java
===================================================================
--- trunk/src/swing/com/mammothsoftware/frwk/ddb/RolloverButton.java	(revision 1040)
+++ trunk/src/swing/com/mammothsoftware/frwk/ddb/RolloverButton.java	(revision 1041)
@@ -14,25 +14,25 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-// Copyright (C) 2005 Mammoth Software LLC
-//
-// This library is free software; you can redistribute it and/or
-// modify it under the terms of the GNU Lesser General Public
-// License as published by the Free Software Foundation; either
-// version 2.1 of the License, or (at your option) any later version.
-//
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-// Lesser General Public License for more details.
-//
-// You should have received a copy of the GNU Lesser General Public
-// License along with this library; if not, write to the Free Software
-// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-//
-// Contact the author at: info@mammothsoftware.com
-package com.mammothsoftware.frwk.ddb;
-
+// Copyright (C) 2005 Mammoth Software LLC
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+//
+// Contact the author at: info@mammothsoftware.com
+package com.mammothsoftware.frwk.ddb;
+
 import java.awt.Dimension;
 import java.awt.event.MouseAdapter;
 import java.awt.event.MouseEvent;
@@ -44,86 +44,86 @@
 import javax.swing.JButton;
 import javax.swing.border.Border;
 import javax.swing.border.CompoundBorder;
-
-/**
- * A button that uses a mouse listener to indicate rollover.
- * 
- * @author m. bangham
- * Copyright 2005 Mammoth Software LLC
- */
-public class RolloverButton extends JButton {
-	
-	public RolloverButton() {
-		init();
-		initRolloverListener();
-	}
-	
-	public RolloverButton(Icon icon, int size) {
-		super(icon);
-		init();
-		initRolloverListener();
-
-		setFixedSize(size);
-	}
-	
-	public RolloverButton(Icon icon, int size, boolean isRollover) {
-		super(icon);
-		init();
-		if (isRollover) initRolloverListener();
-		
-		setFixedSize(size);
-	}
-	
-	public RolloverButton(int size, boolean isRollover) {
-		super();
-		init();
-		if (isRollover) initRolloverListener();
-		
-		setFixedSize(size);
-	}
-	
-	public RolloverButton(Action action, int size) {
-		// Note: using setAction(action) causes both icon and text
-		// to be displayed on toolbar.
-		super((Icon)action.getValue(Action.SMALL_ICON));
-		init();
-		initRolloverListener();
-		addActionListener(action);
-		setFixedSize(size);
-	}
-
-	private void init() {
-		setRequestFocusEnabled(false);
-		setRolloverEnabled(true);
-	}
-	
-	protected void setFixedSize(int size) {
-		setPreferredSize(new Dimension(size, size));
-		setMaximumSize(new Dimension(size, size));
-		setMinimumSize(new Dimension(size, size));
-	}
-	
-	protected void initRolloverListener() {
-		MouseListener l = new MouseAdapter(){
-			Border curBorder = null;
-			public void mouseEntered(MouseEvent e) {
-				curBorder = getBorder();
-				/* Borders can have different insets - get the size and force it
-				 * so the new rollover border doesn't change the button size. */
-				setBorder(new CompoundBorder(getRolloverBorder(), curBorder));
-				getModel().setRollover(true);
-			}
-			public void mouseExited(MouseEvent e) {
-				setBorder(curBorder);
-				getModel().setRollover(false);
-			}
-		};
-		addMouseListener(l);
-	}
-	
-	protected Border getRolloverBorder() {
-		Border border = BorderFactory.createRaisedBevelBorder();
-		
-		return border;
-	}
-}
+
+/**
+ * A button that uses a mouse listener to indicate rollover.
+ * 
+ * @author m. bangham
+ * Copyright 2005 Mammoth Software LLC
+ */
+public class RolloverButton extends JButton {
+	
+	public RolloverButton() {
+		init();
+		initRolloverListener();
+	}
+	
+	public RolloverButton(Icon icon, int size) {
+		super(icon);
+		init();
+		initRolloverListener();
+
+		setFixedSize(size);
+	}
+	
+	public RolloverButton(Icon icon, int size, boolean isRollover) {
+		super(icon);
+		init();
+		if (isRollover) initRolloverListener();
+		
+		setFixedSize(size);
+	}
+	
+	public RolloverButton(int size, boolean isRollover) {
+		super();
+		init();
+		if (isRollover) initRolloverListener();
+		
+		setFixedSize(size);
+	}
+	
+	public RolloverButton(Action action, int size) {
+		// Note: using setAction(action) causes both icon and text
+		// to be displayed on toolbar.
+		super((Icon)action.getValue(Action.SMALL_ICON));
+		init();
+		initRolloverListener();
+		addActionListener(action);
+		setFixedSize(size);
+	}
+
+	private void init() {
+		setRequestFocusEnabled(false);
+		setRolloverEnabled(true);
+	}
+	
+	protected void setFixedSize(int size) {
+		setPreferredSize(new Dimension(size, size));
+		setMaximumSize(new Dimension(size, size));
+		setMinimumSize(new Dimension(size, size));
+	}
+	
+	protected void initRolloverListener() {
+		MouseListener l = new MouseAdapter(){
+			Border curBorder = null;
+			public void mouseEntered(MouseEvent e) {
+				curBorder = getBorder();
+				/* Borders can have different insets - get the size and force it
+				 * so the new rollover border doesn't change the button size. */
+				setBorder(new CompoundBorder(getRolloverBorder(), curBorder));
+				getModel().setRollover(true);
+			}
+			public void mouseExited(MouseEvent e) {
+				setBorder(curBorder);
+				getModel().setRollover(false);
+			}
+		};
+		addMouseListener(l);
+	}
+	
+	protected Border getRolloverBorder() {
+		Border border = BorderFactory.createRaisedBevelBorder();
+		
+		return border;
+	}
+}

Property changes on: trunk/src/swing/com/mammothsoftware/frwk/ddb/RolloverButton.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swing/com/mammothsoftware/frwk/ddb/DropDownButton.java
===================================================================
--- trunk/src/swing/com/mammothsoftware/frwk/ddb/DropDownButton.java	(revision 1040)
+++ trunk/src/swing/com/mammothsoftware/frwk/ddb/DropDownButton.java	(revision 1041)
@@ -14,25 +14,25 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-// Copyright (C) 2005 Mammoth Software LLC
-//
-// This library is free software; you can redistribute it and/or
-// modify it under the terms of the GNU Lesser General Public
-// License as published by the Free Software Foundation; either
-// version 2.1 of the License, or (at your option) any later version.
-//
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-// Lesser General Public License for more details.
-//
-// You should have received a copy of the GNU Lesser General Public
-// License along with this library; if not, write to the Free Software
-// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-//
-// Contact the author at: info@mammothsoftware.com
-package com.mammothsoftware.frwk.ddb;
-
+// Copyright (C) 2005 Mammoth Software LLC
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+//
+// Contact the author at: info@mammothsoftware.com
+package com.mammothsoftware.frwk.ddb;
+
 import java.awt.Color;
 import java.awt.Component;
 import java.awt.Dimension;
@@ -52,206 +52,206 @@
 import javax.swing.JToolBar;
 import javax.swing.border.Border;
 import javax.swing.border.CompoundBorder;
-
-/**
- * A Drop Down Button.
- * 
- * @author m. bangham
- * Copyright 2005 Mammoth Software LLC
- */
-public class DropDownButton extends JButton implements ActionListener {
-	private JPopupMenu popup = new JPopupMenu();
-	private JToolBar tb = new ToolBar();
-	private JButton mainButton;
-	private JButton arrowButton;
-	private ActionListener mainButtonListener = new ActionListener() {
-		public void actionPerformed(ActionEvent e) {
-			Component component = popup.getComponent(0);
-			if (component instanceof JMenuItem) {
-				JMenuItem item = (JMenuItem)component;
-				item.doClick(0);
-			}
-		}
-	};
-	
-	public DropDownButton(Icon icon) {
-		this();
-		mainButton = new RolloverButton(icon, 25, false);
-		arrowButton = new RolloverButton(new DownArrow(), 11, false);
-		init();
-	}
-	
-	public DropDownButton(Icon icon, int size) {
-		this();
-		mainButton = new RolloverButton(icon, size, false);
-		arrowButton = new RolloverButton(new DownArrow(), 11, false);
-		init();
-	}
-	
-	public DropDownButton(RolloverButton mainButton, RolloverButton arrowButton) {
-		this();
-		this.mainButton = mainButton;
-		this.arrowButton = arrowButton;
-		init();
-	}
-	
-	private DropDownButton() {
-		super();
-		setBorder(null);
-	}
-	
-	public void updateUI() {
-		super.updateUI();
-		setBorder(null);
-	}
-	
-	protected Border getRolloverBorder() {
-		return BorderFactory.createRaisedBevelBorder();
-	}
-	
-	private void initRolloverListener() {
-		MouseListener l = new MouseAdapter(){
-			Border mainBorder = null;
-			Border arrowBorder = null;
-			public void mouseEntered(MouseEvent e) {
-				mainBorder = mainButton.getBorder();
-				arrowBorder = mainButton.getBorder();
-				mainButton.setBorder(new CompoundBorder(getRolloverBorder(), mainBorder));
-				arrowButton.setBorder(new CompoundBorder(getRolloverBorder(), arrowBorder));
-				mainButton.getModel().setRollover(true);
-				arrowButton.getModel().setRollover(true);
-			}
-			public void mouseExited(MouseEvent e) {
-				mainButton.setBorder(mainBorder);
-				arrowButton.setBorder(arrowBorder);
-				mainButton.getModel().setRollover(false);
-				arrowButton.getModel().setRollover(false);
-			}
-		};
-		mainButton.addMouseListener(l);
-		arrowButton.addMouseListener(l);
-	}
-	
-	private void init() {
-		initRolloverListener();
-		
-      Icon disDownArrow = new DisabledDownArrow();
-      arrowButton.setDisabledIcon(disDownArrow);
-      arrowButton.setMaximumSize(new Dimension(11,100));
-      mainButton.addActionListener(this); 
-      arrowButton.addActionListener(this);
-      
-      setMargin(new Insets(0, 0, 0, 0));
-      
-      
-      // Windows draws border around buttons, but not toolbar buttons
-      // Using a toolbar keeps the look consistent.
-      tb.setBorder(null);
-      tb.setMargin(new Insets(0, 0, 0, 0));
-      tb.setFloatable(false);
-      tb.add(mainButton);
-      tb.add(arrowButton);
-      add(tb);
-      
-      setFixedSize(mainButton, arrowButton);
-  
-	}
-	/*
-	 * Forces the width of this button to be the sum of the widths of the main
-	 * button and the arrow button. The height is the max of the main button or
-	 * the arrow button.
-	 */
-	private void setFixedSize(JButton mainButton, JButton arrowButton) {
-      int width = (int)(mainButton.getPreferredSize().getWidth() +
-      					arrowButton.getPreferredSize().getWidth());
-      int height = (int)Math.max(mainButton.getPreferredSize().getHeight(),
-      					arrowButton.getPreferredSize().getHeight());
-
-      setMaximumSize(new Dimension(width, height));
-      setMinimumSize(new Dimension(width, height));
-      setPreferredSize(new Dimension(width, height));
-	}
-   
-	/**
-	 * Removes a component from the popup
-	 * @param component
-	 */
-	public void removeComponent(Component component) {
-		popup.remove(component);
-	}
-
-	/**
-	 * Adds a component to the popup
-	 * @param component
-	 * @return
-	 */
-	public Component addComponent(Component component) {
-		return popup.add(component);
-	}
-	
-	/**
-	 * Indicates that the first item in the menu should be executed
-	 * when the main button is clicked
-	 * @param isRunFirstItem True for on, false for off
-	 */
-	public void setRunFirstItem(boolean isRunFirstItem) {
-		mainButton.removeActionListener(this);
-		if (!isRunFirstItem) {
-			mainButton.addActionListener(this);
-		}
-		else
-			mainButton.addActionListener(mainButtonListener);
-	}
-	
-   /*------------------------------[ ActionListener ]---------------------------------------------------*/ 
-	 
-   public void actionPerformed(ActionEvent ae){ 
-        JPopupMenu popup = getPopupMenu(); 
-        popup.show(this, 0, this.getHeight()); 
-    } 
-   
-   protected JPopupMenu getPopupMenu() { return popup; }
-	
-   private static class DownArrow implements Icon {
-   	 
-      Color arrowColor = Color.black;
-
-      public void paintIcon(Component c, Graphics g, int x, int y) {
-          g.setColor(arrowColor);
-          g.drawLine(x, y, x+4, y);
-          g.drawLine(x+1, y+1, x+3, y+1);
-          g.drawLine(x+2, y+2, x+2, y+2);
-      }
-
-      public int getIconWidth() {
-          return 6;
-      }
-
-      public int getIconHeight() {
-          return 4;
-      }
-
-  }
-   
-   private static class DisabledDownArrow extends DownArrow {
-   	 
-      public DisabledDownArrow() {
-          arrowColor = new Color(140, 140, 140);
-      }
-
-      public void paintIcon(Component c, Graphics g, int x, int y) {
-          super.paintIcon(c, g, x, y);
-          g.setColor(Color.white);
-          g.drawLine(x+3, y+2, x+4, y+1);
-          g.drawLine(x+3, y+3, x+5, y+1);
-      }
-  }
-   
-   private static class ToolBar extends JToolBar {
-   	public void updateUI() {
-   		super.updateUI();
-   		setBorder(null);
-   	}
-   }
-
-}
+
+/**
+ * A Drop Down Button.
+ * 
+ * @author m. bangham
+ * Copyright 2005 Mammoth Software LLC
+ */
+public class DropDownButton extends JButton implements ActionListener {
+	private JPopupMenu popup = new JPopupMenu();
+	private JToolBar tb = new ToolBar();
+	private JButton mainButton;
+	private JButton arrowButton;
+	private ActionListener mainButtonListener = new ActionListener() {
+		public void actionPerformed(ActionEvent e) {
+			Component component = popup.getComponent(0);
+			if (component instanceof JMenuItem) {
+				JMenuItem item = (JMenuItem)component;
+				item.doClick(0);
+			}
+		}
+	};
+	
+	public DropDownButton(Icon icon) {
+		this();
+		mainButton = new RolloverButton(icon, 25, false);
+		arrowButton = new RolloverButton(new DownArrow(), 11, false);
+		init();
+	}
+	
+	public DropDownButton(Icon icon, int size) {
+		this();
+		mainButton = new RolloverButton(icon, size, false);
+		arrowButton = new RolloverButton(new DownArrow(), 11, false);
+		init();
+	}
+	
+	public DropDownButton(RolloverButton mainButton, RolloverButton arrowButton) {
+		this();
+		this.mainButton = mainButton;
+		this.arrowButton = arrowButton;
+		init();
+	}
+	
+	private DropDownButton() {
+		super();
+		setBorder(null);
+	}
+	
+	public void updateUI() {
+		super.updateUI();
+		setBorder(null);
+	}
+	
+	protected Border getRolloverBorder() {
+		return BorderFactory.createRaisedBevelBorder();
+	}
+	
+	private void initRolloverListener() {
+		MouseListener l = new MouseAdapter(){
+			Border mainBorder = null;
+			Border arrowBorder = null;
+			public void mouseEntered(MouseEvent e) {
+				mainBorder = mainButton.getBorder();
+				arrowBorder = mainButton.getBorder();
+				mainButton.setBorder(new CompoundBorder(getRolloverBorder(), mainBorder));
+				arrowButton.setBorder(new CompoundBorder(getRolloverBorder(), arrowBorder));
+				mainButton.getModel().setRollover(true);
+				arrowButton.getModel().setRollover(true);
+			}
+			public void mouseExited(MouseEvent e) {
+				mainButton.setBorder(mainBorder);
+				arrowButton.setBorder(arrowBorder);
+				mainButton.getModel().setRollover(false);
+				arrowButton.getModel().setRollover(false);
+			}
+		};
+		mainButton.addMouseListener(l);
+		arrowButton.addMouseListener(l);
+	}
+	
+	private void init() {
+		initRolloverListener();
+		
+      Icon disDownArrow = new DisabledDownArrow();
+      arrowButton.setDisabledIcon(disDownArrow);
+      arrowButton.setMaximumSize(new Dimension(11,100));
+      mainButton.addActionListener(this); 
+      arrowButton.addActionListener(this);
+      
+      setMargin(new Insets(0, 0, 0, 0));
+      
+      
+      // Windows draws border around buttons, but not toolbar buttons
+      // Using a toolbar keeps the look consistent.
+      tb.setBorder(null);
+      tb.setMargin(new Insets(0, 0, 0, 0));
+      tb.setFloatable(false);
+      tb.add(mainButton);
+      tb.add(arrowButton);
+      add(tb);
+      
+      setFixedSize(mainButton, arrowButton);
+  
+	}
+	/*
+	 * Forces the width of this button to be the sum of the widths of the main
+	 * button and the arrow button. The height is the max of the main button or
+	 * the arrow button.
+	 */
+	private void setFixedSize(JButton mainButton, JButton arrowButton) {
+      int width = (int)(mainButton.getPreferredSize().getWidth() +
+      					arrowButton.getPreferredSize().getWidth());
+      int height = (int)Math.max(mainButton.getPreferredSize().getHeight(),
+      					arrowButton.getPreferredSize().getHeight());
+
+      setMaximumSize(new Dimension(width, height));
+      setMinimumSize(new Dimension(width, height));
+      setPreferredSize(new Dimension(width, height));
+	}
+   
+	/**
+	 * Removes a component from the popup
+	 * @param component
+	 */
+	public void removeComponent(Component component) {
+		popup.remove(component);
+	}
+
+	/**
+	 * Adds a component to the popup
+	 * @param component
+	 * @return
+	 */
+	public Component addComponent(Component component) {
+		return popup.add(component);
+	}
+	
+	/**
+	 * Indicates that the first item in the menu should be executed
+	 * when the main button is clicked
+	 * @param isRunFirstItem True for on, false for off
+	 */
+	public void setRunFirstItem(boolean isRunFirstItem) {
+		mainButton.removeActionListener(this);
+		if (!isRunFirstItem) {
+			mainButton.addActionListener(this);
+		}
+		else
+			mainButton.addActionListener(mainButtonListener);
+	}
+	
+   /*------------------------------[ ActionListener ]---------------------------------------------------*/ 
+	 
+   public void actionPerformed(ActionEvent ae){ 
+        JPopupMenu popup = getPopupMenu(); 
+        popup.show(this, 0, this.getHeight()); 
+    } 
+   
+   protected JPopupMenu getPopupMenu() { return popup; }
+	
+   private static class DownArrow implements Icon {
+   	 
+      Color arrowColor = Color.black;
+
+      public void paintIcon(Component c, Graphics g, int x, int y) {
+          g.setColor(arrowColor);
+          g.drawLine(x, y, x+4, y);
+          g.drawLine(x+1, y+1, x+3, y+1);
+          g.drawLine(x+2, y+2, x+2, y+2);
+      }
+
+      public int getIconWidth() {
+          return 6;
+      }
+
+      public int getIconHeight() {
+          return 4;
+      }
+
+  }
+   
+   private static class DisabledDownArrow extends DownArrow {
+   	 
+      public DisabledDownArrow() {
+          arrowColor = new Color(140, 140, 140);
+      }
+
+      public void paintIcon(Component c, Graphics g, int x, int y) {
+          super.paintIcon(c, g, x, y);
+          g.setColor(Color.white);
+          g.drawLine(x+3, y+2, x+4, y+1);
+          g.drawLine(x+3, y+3, x+5, y+1);
+      }
+  }
+   
+   private static class ToolBar extends JToolBar {
+   	public void updateUI() {
+   		super.updateUI();
+   		setBorder(null);
+   	}
+   }
+
+}

Property changes on: trunk/src/swing/com/mammothsoftware/frwk/ddb/DropDownButton.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/v2/org/pathvisio/Globals.java
===================================================================
--- trunk/src/v2/org/pathvisio/Globals.java	(revision 1040)
+++ trunk/src/v2/org/pathvisio/Globals.java	(revision 1041)
@@ -1,32 +1,32 @@
-// PathVisio,
-// a tool for data visualization and analysis using Biological Pathways
-// Copyright 2006-2007 BiGCaT Bioinformatics
-//
-// Licensed under the Apache License, Version 2.0 (the "License"); 
-// you may not use this file except in compliance with the License. 
-// You may obtain a copy of the License at 
-// 
-// http://www.apache.org/licenses/LICENSE-2.0 
-//  
-// Unless required by applicable law or agreed to in writing, software 
-// distributed under the License is distributed on an "AS IS" BASIS, 
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-// See the License for the specific language governing permissions and 
-// limitations under the License.
-//
-package org.pathvisio;
-
-/**
- * This class is mainly intended for globals that differ between v1 and v2!
- * 
- * @author martijn.vaniersel
- *
- */
-public class Globals {
-	public static final String APPLICATION_NAME = "PathVisio";
-	public static final String APPLICATION_VERSION_NAME = "PathVisio 2.0 (experimental)";
-	public static final String HELP_URL = "http://wiki.bigcat.unimaas.nl/pathvisio/Help_v2";
-	// for inclusion in certain error messages.
-	public static final String DEVELOPER_EMAIL = "martijn.vaniersel@bigcat.unimaas.nl"; 
-	public static final boolean fUseExperimentalFeatures = true;
-}
+// PathVisio,
+// a tool for data visualization and analysis using Biological Pathways
+// Copyright 2006-2007 BiGCaT Bioinformatics
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); 
+// you may not use this file except in compliance with the License. 
+// You may obtain a copy of the License at 
+// 
+// http://www.apache.org/licenses/LICENSE-2.0 
+//  
+// Unless required by applicable law or agreed to in writing, software 
+// distributed under the License is distributed on an "AS IS" BASIS, 
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+// See the License for the specific language governing permissions and 
+// limitations under the License.
+//
+package org.pathvisio;
+
+/**
+ * This class is mainly intended for globals that differ between v1 and v2!
+ * 
+ * @author martijn.vaniersel
+ *
+ */
+public class Globals {
+	public static final String APPLICATION_NAME = "PathVisio";
+	public static final String APPLICATION_VERSION_NAME = "PathVisio 2.0 (experimental)";
+	public static final String HELP_URL = "http://wiki.bigcat.unimaas.nl/pathvisio/Help_v2";
+	// for inclusion in certain error messages.
+	public static final String DEVELOPER_EMAIL = "martijn.vaniersel@bigcat.unimaas.nl"; 
+	public static final boolean fUseExperimentalFeatures = true;
+}

Property changes on: trunk/src/v2/org/pathvisio/Globals.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/core/org/pathvisio/model/PathwayImporter.java
===================================================================
--- trunk/src/core/org/pathvisio/model/PathwayImporter.java	(revision 1040)
+++ trunk/src/core/org/pathvisio/model/PathwayImporter.java	(revision 1041)
@@ -14,12 +14,12 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-package org.pathvisio.model;
-
+package org.pathvisio.model;
+
 import java.io.File;
-
-public interface PathwayImporter {
-	public String getName();
-	public String[] getExtensions();	
-	public void doImport(File file, Pathway pathway) throws ConverterException;
-}
+
+public interface PathwayImporter {
+	public String getName();
+	public String[] getExtensions();	
+	public void doImport(File file, Pathway pathway) throws ConverterException;
+}

Property changes on: trunk/src/core/org/pathvisio/model/PathwayImporter.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/core/org/pathvisio/model/PathwayExporter.java
===================================================================
--- trunk/src/core/org/pathvisio/model/PathwayExporter.java	(revision 1040)
+++ trunk/src/core/org/pathvisio/model/PathwayExporter.java	(revision 1041)
@@ -14,12 +14,12 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-package org.pathvisio.model;
-
+package org.pathvisio.model;
+
 import java.io.File;
-
-public interface PathwayExporter {
-	public String getName();
-	public String[] getExtensions();
-	public void doExport(File file, Pathway pathway) throws ConverterException;
-}
+
+public interface PathwayExporter {
+	public String getName();
+	public String[] getExtensions();
+	public void doExport(File file, Pathway pathway) throws ConverterException;
+}

Property changes on: trunk/src/core/org/pathvisio/model/PathwayExporter.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/core/org/pathvisio/model/ImageExporter.java
===================================================================
--- trunk/src/core/org/pathvisio/model/ImageExporter.java	(revision 1040)
+++ trunk/src/core/org/pathvisio/model/ImageExporter.java	(revision 1041)
@@ -14,8 +14,8 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-package org.pathvisio.model;
-
+package org.pathvisio.model;
+
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.OutputStream;
@@ -29,100 +29,100 @@
 import org.jdom.Document;
 import org.jdom.JDOMException;
 import org.jdom.output.DOMOutputter;
-
-public class ImageExporter implements PathwayExporter {
-	public static final int TYPE_PNG = 0;
-	public static final int TYPE_TIFF = 1;
-	public static final int TYPE_PDF = 2;
-	
-	private int type;
-	private String[] extensions;
-	
-	public ImageExporter(int type) {
-		this.type = type;
-	}
-	
-	public String[] getExtensions() {
-		if(extensions == null) {
-			extensions = new String[] { getDefaultExtension() };
-		}
-		return extensions;
-	}
-	
-	public String getDefaultExtension() {
-		switch(type) {
-		case TYPE_PNG:
-			return "png";
-		case TYPE_TIFF:
-			return "tiff";
-		case TYPE_PDF:
-			return "pdf";
-		default:
-			return null;
-		}
-	}
-
-	public String getName() {
-		switch(type) {
-		case TYPE_PNG:
-			return "PNG";
-		case TYPE_TIFF:
-			return "TIFF";
-		case TYPE_PDF:
-			return "PDF";
-		default:
-			return null;
-		}
-		
-	}
-	
-	public void doExport(File file, Pathway pathway) throws ConverterException {
-		Document svg = SvgFormat.createJdom(pathway);
-		
-		Transcoder t = null;
-		switch(type) {
-		case TYPE_PNG:
-			t = new PNGTranscoder();
-			break;
-		case TYPE_TIFF:
-			t = new TIFFTranscoder();
-			break;
-		case TYPE_PDF: try {
-                 Class pdfClass = Class.forName("org.apache.fop.svg.PDFTranscoder");
-                 t = (Transcoder)pdfClass.newInstance();
-             } catch(Exception e) {
-            	 noExporterException();
-             }
-		}
-		if(t == null) noExporterException();
-
-		t.addTranscodingHint(ImageTranscoder.KEY_BACKGROUND_COLOR, java.awt.Color.WHITE);
-
-		try {
-			TranscoderInput input = new TranscoderInput(convertToDOM(svg));
-
-			// Create the transcoder output.
-			OutputStream ostream = new FileOutputStream(file);
-			TranscoderOutput output = new TranscoderOutput(ostream);
-
-			// Save the image.
-			t.transcode(input, output);
-			
-		    // Flush and close the stream.
-	        ostream.flush();
-	        ostream.close();
-		} catch(Exception e) {
-			throw new ConverterException(e);
-		}
-	}
-
-	public void noExporterException() throws ConverterException {
-		throw new ConverterException("No exporter for this image format");
-	}
-
-	public org.w3c.dom.Document convertToDOM(org.jdom.Document jdomDoc) throws JDOMException {
-		DOMOutputter outputter = new DOMOutputter();
-		return outputter.output(jdomDoc);
-	}
-
-}
+
+public class ImageExporter implements PathwayExporter {
+	public static final int TYPE_PNG = 0;
+	public static final int TYPE_TIFF = 1;
+	public static final int TYPE_PDF = 2;
+	
+	private int type;
+	private String[] extensions;
+	
+	public ImageExporter(int type) {
+		this.type = type;
+	}
+	
+	public String[] getExtensions() {
+		if(extensions == null) {
+			extensions = new String[] { getDefaultExtension() };
+		}
+		return extensions;
+	}
+	
+	public String getDefaultExtension() {
+		switch(type) {
+		case TYPE_PNG:
+			return "png";
+		case TYPE_TIFF:
+			return "tiff";
+		case TYPE_PDF:
+			return "pdf";
+		default:
+			return null;
+		}
+	}
+
+	public String getName() {
+		switch(type) {
+		case TYPE_PNG:
+			return "PNG";
+		case TYPE_TIFF:
+			return "TIFF";
+		case TYPE_PDF:
+			return "PDF";
+		default:
+			return null;
+		}
+		
+	}
+	
+	public void doExport(File file, Pathway pathway) throws ConverterException {
+		Document svg = SvgFormat.createJdom(pathway);
+		
+		Transcoder t = null;
+		switch(type) {
+		case TYPE_PNG:
+			t = new PNGTranscoder();
+			break;
+		case TYPE_TIFF:
+			t = new TIFFTranscoder();
+			break;
+		case TYPE_PDF: try {
+                 Class pdfClass = Class.forName("org.apache.fop.svg.PDFTranscoder");
+                 t = (Transcoder)pdfClass.newInstance();
+             } catch(Exception e) {
+            	 noExporterException();
+             }
+		}
+		if(t == null) noExporterException();
+
+		t.addTranscodingHint(ImageTranscoder.KEY_BACKGROUND_COLOR, java.awt.Color.WHITE);
+
+		try {
+			TranscoderInput input = new TranscoderInput(convertToDOM(svg));
+
+			// Create the transcoder output.
+			OutputStream ostream = new FileOutputStream(file);
+			TranscoderOutput output = new TranscoderOutput(ostream);
+
+			// Save the image.
+			t.transcode(input, output);
+			
+		    // Flush and close the stream.
+	        ostream.flush();
+	        ostream.close();
+		} catch(Exception e) {
+			throw new ConverterException(e);
+		}
+	}
+
+	public void noExporterException() throws ConverterException {
+		throw new ConverterException("No exporter for this image format");
+	}
+
+	public org.w3c.dom.Document convertToDOM(org.jdom.Document jdomDoc) throws JDOMException {
+		DOMOutputter outputter = new DOMOutputter();
+		return outputter.output(jdomDoc);
+	}
+
+}

Property changes on: trunk/src/core/org/pathvisio/model/ImageExporter.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/GdbCellEditor.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/GdbCellEditor.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/gui/swt/GdbCellEditor.java	(revision 1041)
@@ -14,8 +14,8 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-package org.pathvisio.gui.swt;
-
+package org.pathvisio.gui.swt;
+
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
@@ -44,219 +44,219 @@
 import org.pathvisio.util.swt.SuggestCombo;
 import org.pathvisio.util.swt.SuggestCombo.SuggestionListener;
 import org.pathvisio.util.swt.SuggestCombo.SuggestionProvider;
-
-public class GdbCellEditor extends SuggestCellEditor implements SuggestionProvider, SuggestionListener {
-	public static final int TYPE_IDENTIFIER = 0;
-	public static final int TYPE_SYMBOL = 1;
-	int type;
-	
-	public static final int NO_LIMIT = 0;
-	public static final int NO_TIMEOUT = 0;
-	public static int query_timeout = 5; //seconds
-	
-	HashMap<String, PropertyPanel.AutoFillData> suggested;
-	
-	Button button;
-	
-	GdbCellEditor(Composite parent, int type) {
-		super();
-		this.type = type;
-		create(parent); //Set type before creating contol
-		suggestCombo.addSuggetsionListener(this);
-		suggested = new HashMap<String, PropertyPanel.AutoFillData>();
-	}
-		
-	protected Control createControl(Composite parent) {
-		if(type == TYPE_IDENTIFIER) {
-			Composite comp = new Composite(parent, SWT.NULL);
-			super.createControl(comp);
-			button = new Button(comp, SWT.PUSH);
-			button.setText("Set Label");
-			button.setToolTipText("Set the Label property by looking up the gene symbol in the synonym database");
-			button.addSelectionListener(new SelectionAdapter() {
-				public void widgetSelected(SelectionEvent e) {
-					Object value = doGetValue();
-					if(value instanceof AutoFillData) {
-						AutoFillData afd = (AutoFillData) value;
-						afd.setDoGuessData(true);
-						fireApplyEditorValue();
-						afd.setDoGuessData(false);
-					}
-				}
-			});
-			comp.setLayout(new CellLayout());
-			return comp;
-		} else {
-			return super.createControl(parent);
-		}
-	}
-	
-	protected void setFocusListeners() {
-        suggestCombo.getControl().addFocusListener(new FocusAdapter() {
-            public void focusLost(FocusEvent e) {
-            	if(!suggestCombo.isSuggestFocus() &&
-            		(button != null && !button.isFocusControl())) { //Also check focus on button
-            		GdbCellEditor.this.focusLost();
-            	}
-            }
-        });
-	}
-	
-    private class CellLayout extends Layout {
-    	//Adapted from DialogCellEditor
-        public void layout(Composite editor, boolean force) {
-            Rectangle bounds = editor.getClientArea();
-            Point size = button.computeSize(SWT.DEFAULT, SWT.DEFAULT, force);
-			suggestCombo.setBounds(0, 0, bounds.width - size.x, bounds.height);
-            button.setBounds(bounds.width - size.x, 0, size.x, bounds.height);
-        }
-
-        public Point computeSize(Composite editor, int wHint, int hHint,
-                boolean force) {
-            if (wHint != SWT.DEFAULT && hHint != SWT.DEFAULT) {
-				return new Point(wHint, hHint);
-			}
-            Point contentsSize = suggestCombo.computeSize(SWT.DEFAULT, SWT.DEFAULT,
-                    force);
-            Point buttonSize = button.computeSize(SWT.DEFAULT, SWT.DEFAULT,
-            		force);
-            Point result = new Point(buttonSize.x, Math.max(contentsSize.y,
-            		buttonSize.y));
-            return result;
-        }
-    }
-
-    public String getLabel(AutoFillData adf) {
-    	String iddb = adf.getProperty(PropertyType.GENEID) + " (" +
-    	adf.getProperty(PropertyType.SYSTEMCODE) + ")";
-    	switch(type) {
-    	case TYPE_IDENTIFIER:
-    		return 	iddb;
-    	case TYPE_SYMBOL:
-    	default:
-    		return adf.getProperty(PropertyType.TEXTLABEL) + ": " + iddb;
-    	}
-				
-	}
-	
-	public SuggestionProvider getSuggestionProvider() {
-		return this;
-	}
-
-	public void suggestionSelected(String suggestion) {
-		suggestCombo.setText(suggestion);
-		fireApplyEditorValue();
-	}
-	
-	protected Object doGetValue() {
-		String text = suggestCombo.getText();
-		AutoFillData suggestion = suggested.get(text);
-		if(suggestion == null) {
-			suggested.put(text, suggestion = new GdbAutoFillData(getMainPropertyType(), text));
-		}
-		return suggestion;
-	}
-	
-	protected PropertyType getMainPropertyType() {
-		switch(type) {
-		case TYPE_IDENTIFIER:
-			return PropertyType.GENEID;
-		case TYPE_SYMBOL:
-		default:
-			return PropertyType.TEXTLABEL;
-		}
-	}
-	
-	public String[] getSuggestions(String text, SuggestCombo suggestCombo) {
-		int limit = getLimit();
-		
-		List<String> sugg = new ArrayList<String>();
-		try {
-			Statement s = Gdb.getCon().createStatement();
-			
-			s.setQueryTimeout(query_timeout);
-			if(limit > NO_LIMIT) s.setMaxRows(limit);
-			
-			String query = "";
-			switch(type) {
-			case TYPE_IDENTIFIER:
-				query =
-						"SELECT id, code FROM gene WHERE " +
-						"id LIKE '" + text + "%'";
-				break;
-			case TYPE_SYMBOL:
-			default:
-				query =
-						"SELECT id, code, backpageText FROM gene WHERE " +
-						"backpageText LIKE '%<TH>Gene Name:<TH>" + text + "%'";
-			}
-			
-			ResultSet r = s.executeQuery(query);
-	
-			while(r.next()) {
-				String sysCode = r.getString("code");
-				String sysName = DataSources.sysCode2Name.get(sysCode);
-				
-				AutoFillData adf = null;
-				switch(type) {
-				case TYPE_IDENTIFIER:
-					adf = new GdbAutoFillData(PropertyType.GENEID, r.getString("id"));
-					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
-					break;
-				case TYPE_SYMBOL:
-				default:
-					String symbol = Gdb.parseGeneSymbol(r.getString("backpageText"));
-					adf = new GdbAutoFillData(PropertyType.TEXTLABEL, symbol);
-					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
-					adf.setProperty(PropertyType.GENEID, r.getString("id"));
-					
-				}
-				
-				String label = getLabel(adf);
-				suggested.put(label, adf);
-				sugg.add(label);
-			}
-		} catch (SQLException e) {
-			Engine.log.error("Unable to query suggestions", e);
-		}
-		if(limit > NO_LIMIT && sugg.size() == limit) sugg.add("...results limited to " + limit);
-		return sugg.toArray(new String[sugg.size()]);
-	}
-
-	int getLimit() {
-		switch(type) {
-		case TYPE_IDENTIFIER:
-			return 100;
-		case TYPE_SYMBOL:
-		default:
-			return 100;
-		}
-	}
-
-	class GdbAutoFillData extends AutoFillData {
-		public GdbAutoFillData(PropertyType mainProperty, String mainValue) {
-			super(mainProperty, mainValue);
-		}
-		
-		protected void guessData(PathwayElement o) {
-			//Fetch info from self
-			String id = getProperty(PropertyType.GENEID);
-			String sysName = getProperty(PropertyType.SYSTEMCODE);
-			
-			//If null, fetch from dataobject
-			if(id == null) id = (String)o.getProperty(PropertyType.GENEID);
-			if(sysName == null) sysName = (String)o.getProperty(PropertyType.SYSTEMCODE);
-			
-			String code = sysName == null ? null : DataSources.sysName2Code.get(sysName);
-			
-			//Guess symbol
-			if(id != null && code != null) {
-				String symbol = Gdb.getGeneSymbol(id, code);
-				if(symbol != null) {
-					setProperty(PropertyType.TEXTLABEL, symbol);
-				}
-			}
-		}
-	}
-
-}
+
+public class GdbCellEditor extends SuggestCellEditor implements SuggestionProvider, SuggestionListener {
+	public static final int TYPE_IDENTIFIER = 0;
+	public static final int TYPE_SYMBOL = 1;
+	int type;
+	
+	public static final int NO_LIMIT = 0;
+	public static final int NO_TIMEOUT = 0;
+	public static int query_timeout = 5; //seconds
+	
+	HashMap<String, PropertyPanel.AutoFillData> suggested;
+	
+	Button button;
+	
+	GdbCellEditor(Composite parent, int type) {
+		super();
+		this.type = type;
+		create(parent); //Set type before creating contol
+		suggestCombo.addSuggetsionListener(this);
+		suggested = new HashMap<String, PropertyPanel.AutoFillData>();
+	}
+		
+	protected Control createControl(Composite parent) {
+		if(type == TYPE_IDENTIFIER) {
+			Composite comp = new Composite(parent, SWT.NULL);
+			super.createControl(comp);
+			button = new Button(comp, SWT.PUSH);
+			button.setText("Set Label");
+			button.setToolTipText("Set the Label property by looking up the gene symbol in the synonym database");
+			button.addSelectionListener(new SelectionAdapter() {
+				public void widgetSelected(SelectionEvent e) {
+					Object value = doGetValue();
+					if(value instanceof AutoFillData) {
+						AutoFillData afd = (AutoFillData) value;
+						afd.setDoGuessData(true);
+						fireApplyEditorValue();
+						afd.setDoGuessData(false);
+					}
+				}
+			});
+			comp.setLayout(new CellLayout());
+			return comp;
+		} else {
+			return super.createControl(parent);
+		}
+	}
+	
+	protected void setFocusListeners() {
+        suggestCombo.getControl().addFocusListener(new FocusAdapter() {
+            public void focusLost(FocusEvent e) {
+            	if(!suggestCombo.isSuggestFocus() &&
+            		(button != null && !button.isFocusControl())) { //Also check focus on button
+            		GdbCellEditor.this.focusLost();
+            	}
+            }
+        });
+	}
+	
+    private class CellLayout extends Layout {
+    	//Adapted from DialogCellEditor
+        public void layout(Composite editor, boolean force) {
+            Rectangle bounds = editor.getClientArea();
+            Point size = button.computeSize(SWT.DEFAULT, SWT.DEFAULT, force);
+			suggestCombo.setBounds(0, 0, bounds.width - size.x, bounds.height);
+            button.setBounds(bounds.width - size.x, 0, size.x, bounds.height);
+        }
+
+        public Point computeSize(Composite editor, int wHint, int hHint,
+                boolean force) {
+            if (wHint != SWT.DEFAULT && hHint != SWT.DEFAULT) {
+				return new Point(wHint, hHint);
+			}
+            Point contentsSize = suggestCombo.computeSize(SWT.DEFAULT, SWT.DEFAULT,
+                    force);
+            Point buttonSize = button.computeSize(SWT.DEFAULT, SWT.DEFAULT,
+            		force);
+            Point result = new Point(buttonSize.x, Math.max(contentsSize.y,
+            		buttonSize.y));
+            return result;
+        }
+    }
+
+    public String getLabel(AutoFillData adf) {
+    	String iddb = adf.getProperty(PropertyType.GENEID) + " (" +
+    	adf.getProperty(PropertyType.SYSTEMCODE) + ")";
+    	switch(type) {
+    	case TYPE_IDENTIFIER:
+    		return 	iddb;
+    	case TYPE_SYMBOL:
+    	default:
+    		return adf.getProperty(PropertyType.TEXTLABEL) + ": " + iddb;
+    	}
+				
+	}
+	
+	public SuggestionProvider getSuggestionProvider() {
+		return this;
+	}
+
+	public void suggestionSelected(String suggestion) {
+		suggestCombo.setText(suggestion);
+		fireApplyEditorValue();
+	}
+	
+	protected Object doGetValue() {
+		String text = suggestCombo.getText();
+		AutoFillData suggestion = suggested.get(text);
+		if(suggestion == null) {
+			suggested.put(text, suggestion = new GdbAutoFillData(getMainPropertyType(), text));
+		}
+		return suggestion;
+	}
+	
+	protected PropertyType getMainPropertyType() {
+		switch(type) {
+		case TYPE_IDENTIFIER:
+			return PropertyType.GENEID;
+		case TYPE_SYMBOL:
+		default:
+			return PropertyType.TEXTLABEL;
+		}
+	}
+	
+	public String[] getSuggestions(String text, SuggestCombo suggestCombo) {
+		int limit = getLimit();
+		
+		List<String> sugg = new ArrayList<String>();
+		try {
+			Statement s = Gdb.getCon().createStatement();
+			
+			s.setQueryTimeout(query_timeout);
+			if(limit > NO_LIMIT) s.setMaxRows(limit);
+			
+			String query = "";
+			switch(type) {
+			case TYPE_IDENTIFIER:
+				query =
+						"SELECT id, code FROM gene WHERE " +
+						"id LIKE '" + text + "%'";
+				break;
+			case TYPE_SYMBOL:
+			default:
+				query =
+						"SELECT id, code, backpageText FROM gene WHERE " +
+						"backpageText LIKE '%<TH>Gene Name:<TH>" + text + "%'";
+			}
+			
+			ResultSet r = s.executeQuery(query);
+	
+			while(r.next()) {
+				String sysCode = r.getString("code");
+				String sysName = DataSources.sysCode2Name.get(sysCode);
+				
+				AutoFillData adf = null;
+				switch(type) {
+				case TYPE_IDENTIFIER:
+					adf = new GdbAutoFillData(PropertyType.GENEID, r.getString("id"));
+					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
+					break;
+				case TYPE_SYMBOL:
+				default:
+					String symbol = Gdb.parseGeneSymbol(r.getString("backpageText"));
+					adf = new GdbAutoFillData(PropertyType.TEXTLABEL, symbol);
+					adf.setProperty(PropertyType.SYSTEMCODE, sysName);
+					adf.setProperty(PropertyType.GENEID, r.getString("id"));
+					
+				}
+				
+				String label = getLabel(adf);
+				suggested.put(label, adf);
+				sugg.add(label);
+			}
+		} catch (SQLException e) {
+			Engine.log.error("Unable to query suggestions", e);
+		}
+		if(limit > NO_LIMIT && sugg.size() == limit) sugg.add("...results limited to " + limit);
+		return sugg.toArray(new String[sugg.size()]);
+	}
+
+	int getLimit() {
+		switch(type) {
+		case TYPE_IDENTIFIER:
+			return 100;
+		case TYPE_SYMBOL:
+		default:
+			return 100;
+		}
+	}
+
+	class GdbAutoFillData extends AutoFillData {
+		public GdbAutoFillData(PropertyType mainProperty, String mainValue) {
+			super(mainProperty, mainValue);
+		}
+		
+		protected void guessData(PathwayElement o) {
+			//Fetch info from self
+			String id = getProperty(PropertyType.GENEID);
+			String sysName = getProperty(PropertyType.SYSTEMCODE);
+			
+			//If null, fetch from dataobject
+			if(id == null) id = (String)o.getProperty(PropertyType.GENEID);
+			if(sysName == null) sysName = (String)o.getProperty(PropertyType.SYSTEMCODE);
+			
+			String code = sysName == null ? null : DataSources.sysName2Code.get(sysName);
+			
+			//Guess symbol
+			if(id != null && code != null) {
+				String symbol = Gdb.getGeneSymbol(id, code);
+				if(symbol != null) {
+					setProperty(PropertyType.TEXTLABEL, symbol);
+				}
+			}
+		}
+	}
+
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/GdbCellEditor.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/StackActions.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/StackActions.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/gui/swt/StackActions.java	(revision 1041)
@@ -1,38 +1,38 @@
-//	 PathVisio,
-//	 a tool for data visualization and analysis using Biological Pathways
-//	 Copyright 2006-2007 BiGCaT Bioinformatics
-	//
-//	 Licensed under the Apache License, Version 2.0 (the "License"); 
-//	 you may not use this file except in compliance with the License. 
-//	 You may obtain a copy of the License at 
-//	 
-//	 http://www.apache.org/licenses/LICENSE-2.0 
-//	  
-//	 Unless required by applicable law or agreed to in writing, software 
-//	 distributed under the License is distributed on an "AS IS" BASIS, 
-//	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-//	 See the License for the specific language governing permissions and 
-//	 limitations under the License.
-	//
-
-package org.pathvisio.gui.swt;
-
-import org.eclipse.jface.action.Action;
-import org.eclipse.jface.resource.ImageDescriptor;
-import org.pathvisio.Engine;
-import org.pathvisio.view.StackType;
-public class StackActions extends Action {
-	MainWindowBase window;
-	StackType type;
-	
-	public StackActions(StackType t, MainWindowBase w) {
-		window = w;
-		type = t;
-		setToolTipText (type.getDescription());
-		setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL(type.getIcon())));
-	}
-	
-	public void run () {
-		Engine.getActiveVPathway().stackSelected(type);
-	}
+//	 PathVisio,
+//	 a tool for data visualization and analysis using Biological Pathways
+//	 Copyright 2006-2007 BiGCaT Bioinformatics
+	//
+//	 Licensed under the Apache License, Version 2.0 (the "License"); 
+//	 you may not use this file except in compliance with the License. 
+//	 You may obtain a copy of the License at 
+//	 
+//	 http://www.apache.org/licenses/LICENSE-2.0 
+//	  
+//	 Unless required by applicable law or agreed to in writing, software 
+//	 distributed under the License is distributed on an "AS IS" BASIS, 
+//	 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+//	 See the License for the specific language governing permissions and 
+//	 limitations under the License.
+	//
+
+package org.pathvisio.gui.swt;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.pathvisio.Engine;
+import org.pathvisio.view.StackType;
+public class StackActions extends Action {
+	MainWindowBase window;
+	StackType type;
+	
+	public StackActions(StackType t, MainWindowBase w) {
+		window = w;
+		type = t;
+		setToolTipText (type.getDescription());
+		setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL(type.getIcon())));
+	}
+	
+	public void run () {
+		Engine.getActiveVPathway().stackSelected(type);
+	}
 }
\ No newline at end of file

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/StackActions.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/AlignActions.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/AlignActions.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/gui/swt/AlignActions.java	(revision 1041)
@@ -1,40 +1,40 @@
-//PathVisio,
-//a tool for data visualization and analysis using Biological Pathways
-//Copyright 2006-2007 BiGCaT Bioinformatics
-//
-//Licensed under the Apache License, Version 2.0 (the "License"); 
-//you may not use this file except in compliance with the License. 
-//You may obtain a copy of the License at 
-
-//http://www.apache.org/licenses/LICENSE-2.0 
-
-//Unless required by applicable law or agreed to in writing, software 
-//distributed under the License is distributed on an "AS IS" BASIS, 
-//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-//See the License for the specific language governing permissions and 
-//limitations under the License.
-//
-
-package org.pathvisio.gui.swt;
-
-import org.eclipse.jface.action.Action;
-import org.eclipse.jface.resource.ImageDescriptor;
-import org.pathvisio.Engine;
-import org.pathvisio.view.AlignType;
-public class AlignActions extends Action {
-	MainWindowBase window;
-	AlignType type;
-
-	public AlignActions(AlignType t, MainWindowBase w) {
-		window = w;
-		type = t;
-		setToolTipText (type.getDescription());
-		setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL(type.getIcon())));
-	}
-
-	public void run () {
-		Engine.getActiveVPathway().alignSelected(type);
-	}
-}	
-
-
+//PathVisio,
+//a tool for data visualization and analysis using Biological Pathways
+//Copyright 2006-2007 BiGCaT Bioinformatics
+//
+//Licensed under the Apache License, Version 2.0 (the "License"); 
+//you may not use this file except in compliance with the License. 
+//You may obtain a copy of the License at 
+
+//http://www.apache.org/licenses/LICENSE-2.0 
+
+//Unless required by applicable law or agreed to in writing, software 
+//distributed under the License is distributed on an "AS IS" BASIS, 
+//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+//See the License for the specific language governing permissions and 
+//limitations under the License.
+//
+
+package org.pathvisio.gui.swt;
+
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.resource.ImageDescriptor;
+import org.pathvisio.Engine;
+import org.pathvisio.view.AlignType;
+public class AlignActions extends Action {
+	MainWindowBase window;
+	AlignType type;
+
+	public AlignActions(AlignType t, MainWindowBase w) {
+		window = w;
+		type = t;
+		setToolTipText (type.getDescription());
+		setImageDescriptor(ImageDescriptor.createFromURL(Engine.getResourceURL(type.getIcon())));
+	}
+
+	public void run () {
+		Engine.getActiveVPathway().alignSelected(type);
+	}
+}	
+
+

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/AlignActions.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/awt/SwtInputBlocker.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/awt/SwtInputBlocker.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/gui/swt/awt/SwtInputBlocker.java	(revision 1041)
@@ -14,114 +14,114 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-/*******************************************************************************
- * Copyright (c) 2007 SAS Institute.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     SAS Institute - initial API and implementation
- *******************************************************************************/
-package org.pathvisio.gui.swt.awt;
-
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
 import org.eclipse.swt.SWT;
 import org.eclipse.swt.events.FocusAdapter;
 import org.eclipse.swt.events.FocusEvent;
 import org.eclipse.swt.widgets.Dialog;
 import org.eclipse.swt.widgets.Display;
 import org.eclipse.swt.widgets.Shell;
-
-
-
-class SwtInputBlocker extends Dialog {
-    static private SwtInputBlocker instance = null;
-    static private int blockCount = 0;
-    private Shell shell;
-
-    private SwtInputBlocker(Shell parent) {
-        super(parent, SWT.NONE); 
-    }
-    
-    private Object open() {
-        assert Display.getCurrent() != null;     // On SWT event thread
-        
-        final Shell parent = getParent();
-        shell = new Shell(parent, SWT.APPLICATION_MODAL);
-        shell.setSize(0, 0);
-        shell.addFocusListener(new FocusAdapter() {
-            public void focusGained(FocusEvent e) {
-                // On some platforms (e.g. Linux/GTK), the 0x0 shell still appears as a dot 
-                // on the screen, so make it invisible by moving it below other windows. This
-                // is unnecessary under Windows and causes a flash, so only make the call when necessary. 
-                if (Platform.isGtk()) {
-                    shell.moveBelow(null);
-                }
-                AwtEnvironment.getInstance(shell.getDisplay()).requestAwtDialogFocus();
-            }
-        });
-        shell.open();
-        
-        Display display = parent.getDisplay();
-        while (!shell.isDisposed()) {
-            if (!display.readAndDispatch()) {
-                display.sleep();
-            }
-        }
-        return null;
-    }
-
-    private void close() {
-        assert shell != null;
-        
-        shell.dispose();
-    }
-
-    static void unblock() {
-        assert blockCount >= 0;
-        assert Display.getCurrent() != null;  // On SWT event thread
-
-        
-        // System.out.println("Deleting SWT blocker");
-        if (blockCount == 0) {
-            return;
-        }
-        if ((blockCount == 1) && (instance != null)) {
-            instance.close();
-            instance = null;
-        }
-        blockCount--;
-    }
-    
-    static void block() {
-        assert blockCount >= 0;
-        
-        // System.out.println("Creating SWT blocker");
-        final Display display = Display.getCurrent();
-        assert display != null;  // On SWT event thread
-        
-        blockCount++;
-        if (blockCount == 1) {
-            assert instance == null;  // should be no existing blocker
-            
-            // get a shell to parent the blocking dialog
-            Shell shell = AwtEnvironment.getInstance(display).getShell();
-
-            // If there is a shell to block, block input now. If there are no shells, 
-            // then there is no input to block. In the case of no shells, we are not
-            // protecting against a shell that might get created later. This is a rare
-            // enough case to skip, at least for now. In the future, a listener could be 
-            // added to cover it. 
-            // TODO: if (shell==null) add listener to block shells created later?
-            //
-            // Block is implemented with a hidden modal dialog. Using setEnabled(false) is another option, but 
-            // on some platforms that will grey the disabled controls.
-            if (shell != null) {
-                instance = new SwtInputBlocker(shell);
-                instance.open();
-            }
-        }
-    }
-
-}
+
+
+
+class SwtInputBlocker extends Dialog {
+    static private SwtInputBlocker instance = null;
+    static private int blockCount = 0;
+    private Shell shell;
+
+    private SwtInputBlocker(Shell parent) {
+        super(parent, SWT.NONE); 
+    }
+    
+    private Object open() {
+        assert Display.getCurrent() != null;     // On SWT event thread
+        
+        final Shell parent = getParent();
+        shell = new Shell(parent, SWT.APPLICATION_MODAL);
+        shell.setSize(0, 0);
+        shell.addFocusListener(new FocusAdapter() {
+            public void focusGained(FocusEvent e) {
+                // On some platforms (e.g. Linux/GTK), the 0x0 shell still appears as a dot 
+                // on the screen, so make it invisible by moving it below other windows. This
+                // is unnecessary under Windows and causes a flash, so only make the call when necessary. 
+                if (Platform.isGtk()) {
+                    shell.moveBelow(null);
+                }
+                AwtEnvironment.getInstance(shell.getDisplay()).requestAwtDialogFocus();
+            }
+        });
+        shell.open();
+        
+        Display display = parent.getDisplay();
+        while (!shell.isDisposed()) {
+            if (!display.readAndDispatch()) {
+                display.sleep();
+            }
+        }
+        return null;
+    }
+
+    private void close() {
+        assert shell != null;
+        
+        shell.dispose();
+    }
+
+    static void unblock() {
+        assert blockCount >= 0;
+        assert Display.getCurrent() != null;  // On SWT event thread
+
+        
+        // System.out.println("Deleting SWT blocker");
+        if (blockCount == 0) {
+            return;
+        }
+        if ((blockCount == 1) && (instance != null)) {
+            instance.close();
+            instance = null;
+        }
+        blockCount--;
+    }
+    
+    static void block() {
+        assert blockCount >= 0;
+        
+        // System.out.println("Creating SWT blocker");
+        final Display display = Display.getCurrent();
+        assert display != null;  // On SWT event thread
+        
+        blockCount++;
+        if (blockCount == 1) {
+            assert instance == null;  // should be no existing blocker
+            
+            // get a shell to parent the blocking dialog
+            Shell shell = AwtEnvironment.getInstance(display).getShell();
+
+            // If there is a shell to block, block input now. If there are no shells, 
+            // then there is no input to block. In the case of no shells, we are not
+            // protecting against a shell that might get created later. This is a rare
+            // enough case to skip, at least for now. In the future, a listener could be 
+            // added to cover it. 
+            // TODO: if (shell==null) add listener to block shells created later?
+            //
+            // Block is implemented with a hidden modal dialog. Using setEnabled(false) is another option, but 
+            // on some platforms that will grey the disabled controls.
+            if (shell != null) {
+                instance = new SwtInputBlocker(shell);
+                instance.open();
+            }
+        }
+    }
+
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/awt/SwtInputBlocker.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/awt/AwtEnvironment.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/awt/AwtEnvironment.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/gui/swt/awt/AwtEnvironment.java	(revision 1041)
@@ -14,18 +14,18 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-/*******************************************************************************
- * Copyright (c) 2007 SAS Institute.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     SAS Institute - initial API and implementation
- *******************************************************************************/
-package org.pathvisio.gui.swt.awt;
-
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
 import java.awt.EventQueue;
 import java.awt.Frame;
 import java.lang.reflect.InvocationTargetException;
@@ -39,315 +39,315 @@
 import org.eclipse.swt.widgets.Composite;
 import org.eclipse.swt.widgets.Display;
 import org.eclipse.swt.widgets.Shell;
-
-
-
-/**
- * An environment to enable the proper display of AWT/Swing windows within a SWT or RCP 
- * application. This class extends the base {@link org.eclipse.swt.awt.SWT_AWT Eclipse SWT/AWT integration}
- * support by
- * <ul>
- * <li>Using the platform-specific system Look and Feel. 
- * <li>Ensuring AWT modal dialogs are modal across the SWT application.
- * <li>Working around various AWT/Swing bugs  
- * </ul>
- * <p>
- * This class is most helpful to applications which create new AWT/Swing windows (e.g. dialogs) rather
- * than those which embed AWT/Swing components in SWT windows. For support specific to embedding
- * AWT/Swing components see {@link EmbeddedSwingComposite}.
- * <p>
- * There is at most one instance of this class per SWT
- * {@link org.eclipse.swt.widgets.Display Display}. In almost all applications
- * this means that there is exactly one instance for the entire application. In fact, the
- * current implementation always limits the number of instances to exactly one.
- * <p>
- * An instance of this class can be obtained with the static
- * {@link #getInstance(Display)} method.
-*/
-public final class AwtEnvironment {
-    // TODO: add pop-up dismissal and font synchronization support to this level?
-    
-    private static final String GTK_LOOK_AND_FEEL_NAME = "com.sun.java.swing.plaf.gtk.GTKLookAndFeel"; //$NON-NLS-1$
-
-    private static AwtEnvironment instance = null;
-    private static boolean isLookAndFeelInitialized = false;
-
-    private final Display display;
-    private final AwtDialogListener dialogListener;
-
-    /**
-     * Returns the single instance of AwtEnvironment for the given display. On
-     * the first call to this method, the necessary initialization to allow
-     * AWT/Swing code to run properly within an Eclipse application is done.
-     * This initialization includes setting the approprite look and feel and
-     * registering the necessary listeners to ensure proper behavior of modal
-     * dialogs.
-     * <p>
-     * The first call to this method must occur before any AWT/Swing APIs are
-     * called. 
-     * <p>
-     * The current implementation limits the number of instances of
-     * AwtEnvironment to one. If this method is called with a display different
-     * to one used on a previous call, {@link UnsupportedOperationException} is
-     * thrown.
-     * 
-     * @param display
-     *            the non-null SWT display
-     * @return the AWT environment
-     * @exception IllegalArgumentException
-     *                <ul>
-     *                <li>ERROR_NULL_ARGUMENT - if the display is null</li>
-     *                </ul>
-     * @exception UnsupportedOperationException -
-     *                on attempt to use multiple displays.
-     */
-    public static AwtEnvironment getInstance(Display display) {
-        // For now assume a single display. If necessary, this implementation
-        // can be changed to create multiple environments for multiple display
-        // applications.
-        // TODO: add multiple display support
-        if (display == null) {
-            SWT.error(SWT.ERROR_NULL_ARGUMENT);
-        }
-        if ((instance != null) && !display.equals(instance.display)) {
-            throw new UnsupportedOperationException("Multiple displays not supported");
-        }
-        synchronized (AwtEnvironment.class) {
-            if (instance == null) {
-                instance = new AwtEnvironment(display);
-            }
-        }
-        return instance;
-    }
-
-    // Private constructor - clients use getInstance() to obtain instances
-    private AwtEnvironment(Display display) {
-        assert display != null;
-
-        /*
-         * This property removes a large amount of flicker from embedded swing
-         * components. Ideally it would not be set until EmbeddedSwingComposite
-         * is used, but since its value is read once and cached by AWT, it needs
-         * to be set before any AWT/Swing APIs are called.
-         */       
-        // TODO: this is effective only on Windows.
-        System.setProperty("sun.awt.noerasebackground", "true"); //$NON-NLS-1$//$NON-NLS-2$
-
-        /*
-         * RCP apps always want the standard platform look and feel It's
-         * important to wait for the L&F to be set so that any subsequent calls
-         * to createFrame() will be return a frame with the proper L&F (note
-         * that createFrame() happens on the SWT thread).
-         * 
-         * The call to invokeAndWait is safe because
-         * the first call AwtEnvironment.getInstance should happen
-         * before any (potential deadlocking) activity occurs on the 
-         * AWT thread.
-         */
-        try {
-            EventQueue.invokeAndWait(new Runnable() {
-                public void run() {
-                    setSystemLookAndFeel();
-                }
-            });
-        } catch (InterruptedException e) {
-            SWT.error(SWT.ERROR_FAILED_EXEC, e);
-        } catch (InvocationTargetException e) {
-            SWT.error(SWT.ERROR_FAILED_EXEC, e);
-        }
-
-        this.display = display;
-
-        // Listen for AWT modal dialogs to make them modal application-wide
-        dialogListener = new AwtDialogListener(display);
-    }
-
-    /**
-     * Invokes the given runnable in the AWT event thread while blocking user
-     * input on the SWT event thread. The SWT event thread will remain blocked
-     * until the runnable task completes, at which point this method will
-     * return.
-     * <p>
-     * This method is useful for displayng modal AWT/Swing dialogs from the SWT
-     * event thread. The modal AWT/Swing dialog will always block input across
-     * the whole application, but not until it appears. By calling this method,
-     * it is guaranteed that SWT input is blocked immediately, even before the
-     * AWT/Swing dialog appears.
-     * <p>
-     * To avoid unnecessary flicker, AWT/Swing dialogs should have their parent
-     * set to a frame returned by {@link #createDialogParentFrame()}.
-     * <p>
-     * This method must be called from the SWT event thread.
-     * 
-     * @param runnable
-     *            the code to schedule on the AWT event thread
-     * @exception IllegalArgumentException
-     *                <ul>
-     *                <li>ERROR_NULL_ARGUMENT - if the runnable is null</li>
-     *                </ul>
-     * @exception SWTException
-     *                <ul>
-     *                <li>ERROR_THREAD_INVALID_ACCESS - if not called from the
-     *                SWT event thread
-     *                </ul>
-     */
-    public void invokeAndBlockSwt(final Runnable runnable) {
-        assert display != null;
-
-        /*
-         * This code snippet is based on the following thread on
-         * news.eclipse.platform.swt:
-         * http://dev.eclipse.org/newslists/news.eclipse.platform.swt/msg24234.html
-         */
-        if (runnable == null) {
-            SWT.error(SWT.ERROR_NULL_ARGUMENT);
-        }
-        if (display != Display.getCurrent()) {
-            SWT.error(SWT.ERROR_THREAD_INVALID_ACCESS);
-        }
-
-        // Switch to the AWT thread...
-        EventQueue.invokeLater(new Runnable() {
-            public void run() {
-                try {
-                    // do swing work...
-                    runnable.run();
-                } finally {
-                    display.asyncExec(new Runnable() {
-                        public void run() {
-                            // Unblock SWT
-                            SwtInputBlocker.unblock();
-                        }
-                    });
-                }
-            }
-        });
-
-        // Prevent user input on SWT components
-        SwtInputBlocker.block();
-    }
-
-    /**
-     * Creates an AWT frame suitable as a parent for AWT/Swing dialogs. 
-     * <p>
-     * This method must be called from the SWT event thread. There must be an active
-     * shell associated with the environment's display.  
-     * <p>
-     * The created frame is a non-visible child of the active shell and will be disposed when that shell
-     * is disposed.
-     * <p>
-     * See {@link #createDialogParentFrame(Shell)} for more details. 
-     * 
-     * @return a {@link java.awt.Frame} to be used for parenting dialogs
-     * @exception SWTException
-     *                <ul>
-     *                <li>ERROR_THREAD_INVALID_ACCESS - if not called from the
-     *                SWT event thread
-     *                </ul>
-     * @exception IllegalStateException
-     *                if the current display has no shells
-     */
-    public Frame createDialogParentFrame() {
-        if (display != Display.getCurrent()) {
-            SWT.error(SWT.ERROR_THREAD_INVALID_ACCESS);
-        }
-        Shell parent = display.getActiveShell();
-        if (parent == null) {
-            throw new IllegalStateException("No Active Shell");
-        }
-        return createDialogParentFrame(parent);
-    }
-    
-    /**
-     * Creates an AWT frame suitable as a parent for AWT/Swing dialogs. 
-     * <p>
-     * This method must be called from the SWT event thread. There must be an active
-     * shell associated with the environment's display.
-     * <p>
-     * The created frame is a non-visible child of the given shell and will be disposed when that shell
-     * is disposed.
-     * <p>
-     * This method is useful for creating a frame to parent any AWT/Swing
-     * dialogs created for use inside a SWT application. A modal AWT/Swing
-     * dialogs will flicker less if its parent is set to the returned frame
-     * rather than to null or to an independently created {@link java.awt.Frame}.  
-     * 
-     * @return a {@link java.awt.Frame} to be used for parenting dialogs
-     * @exception SWTException
-     *                <ul>
-     *                <li>ERROR_THREAD_INVALID_ACCESS - if not called from the
-     *                SWT event thread
-     *                </ul>
-     * @exception IllegalStateException
-     *                if the current display has no shells
-     */
-    public Frame createDialogParentFrame(Shell parent) {
-        if (parent == null) {
-            SWT.error(SWT.ERROR_NULL_ARGUMENT);
-        }
-        if (display != Display.getCurrent()) {
-            SWT.error(SWT.ERROR_THREAD_INVALID_ACCESS);
-        }
-        Shell shell = new Shell(parent);
-        shell.setVisible(false);
-        Composite composite = new Composite(shell, SWT.EMBEDDED);
-        return SWT_AWT.new_Frame(composite);
-    }
-
-    // Find a shell to use, giving preference to the active shell.
-    Shell getShell() {
-        Shell shell = display.getActiveShell();
-        if (shell == null) {
-            Shell[] allShells = display.getShells();
-            if (allShells.length > 0) {
-                shell = allShells[0];
-            }
-        }
-        return shell;
-    }
-
-    void requestAwtDialogFocus() {
-        assert dialogListener != null;
-
-        dialogListener.requestFocus();
-    }
-
-    private void setSystemLookAndFeel() {
-        assert EventQueue.isDispatchThread(); // On AWT event thread
-
-        if (!isLookAndFeelInitialized) {
-            isLookAndFeelInitialized = true;
-            try {
-                String systemLaf = UIManager.getSystemLookAndFeelClassName();
-                String xplatLaf = UIManager.getCrossPlatformLookAndFeelClassName();
-
-                // Java makes metal the system look and feel if running under a
-                // non-gnome Linux desktop. Fix that here, if the RCP itself is
-                // running
-                // with the GTK windowing system set.
-                if (xplatLaf.equals(systemLaf) && Platform.isGtk()) {
-                    systemLaf = GTK_LOOK_AND_FEEL_NAME;
-                }
-                UIManager.setLookAndFeel(systemLaf);
-            } catch (ClassNotFoundException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            } catch (InstantiationException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            } catch (IllegalAccessException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            } catch (UnsupportedLookAndFeelException e) {
-                // TODO Auto-generated catch block
-                e.printStackTrace();
-            }
-        }
-    }
-    
-    // This method is called by unit tests
-    static void reset() {
-        instance = null;
-    }
-
-}
+
+
+
+/**
+ * An environment to enable the proper display of AWT/Swing windows within a SWT or RCP 
+ * application. This class extends the base {@link org.eclipse.swt.awt.SWT_AWT Eclipse SWT/AWT integration}
+ * support by
+ * <ul>
+ * <li>Using the platform-specific system Look and Feel. 
+ * <li>Ensuring AWT modal dialogs are modal across the SWT application.
+ * <li>Working around various AWT/Swing bugs  
+ * </ul>
+ * <p>
+ * This class is most helpful to applications which create new AWT/Swing windows (e.g. dialogs) rather
+ * than those which embed AWT/Swing components in SWT windows. For support specific to embedding
+ * AWT/Swing components see {@link EmbeddedSwingComposite}.
+ * <p>
+ * There is at most one instance of this class per SWT
+ * {@link org.eclipse.swt.widgets.Display Display}. In almost all applications
+ * this means that there is exactly one instance for the entire application. In fact, the
+ * current implementation always limits the number of instances to exactly one.
+ * <p>
+ * An instance of this class can be obtained with the static
+ * {@link #getInstance(Display)} method.
+*/
+public final class AwtEnvironment {
+    // TODO: add pop-up dismissal and font synchronization support to this level?
+    
+    private static final String GTK_LOOK_AND_FEEL_NAME = "com.sun.java.swing.plaf.gtk.GTKLookAndFeel"; //$NON-NLS-1$
+
+    private static AwtEnvironment instance = null;
+    private static boolean isLookAndFeelInitialized = false;
+
+    private final Display display;
+    private final AwtDialogListener dialogListener;
+
+    /**
+     * Returns the single instance of AwtEnvironment for the given display. On
+     * the first call to this method, the necessary initialization to allow
+     * AWT/Swing code to run properly within an Eclipse application is done.
+     * This initialization includes setting the approprite look and feel and
+     * registering the necessary listeners to ensure proper behavior of modal
+     * dialogs.
+     * <p>
+     * The first call to this method must occur before any AWT/Swing APIs are
+     * called. 
+     * <p>
+     * The current implementation limits the number of instances of
+     * AwtEnvironment to one. If this method is called with a display different
+     * to one used on a previous call, {@link UnsupportedOperationException} is
+     * thrown.
+     * 
+     * @param display
+     *            the non-null SWT display
+     * @return the AWT environment
+     * @exception IllegalArgumentException
+     *                <ul>
+     *                <li>ERROR_NULL_ARGUMENT - if the display is null</li>
+     *                </ul>
+     * @exception UnsupportedOperationException -
+     *                on attempt to use multiple displays.
+     */
+    public static AwtEnvironment getInstance(Display display) {
+        // For now assume a single display. If necessary, this implementation
+        // can be changed to create multiple environments for multiple display
+        // applications.
+        // TODO: add multiple display support
+        if (display == null) {
+            SWT.error(SWT.ERROR_NULL_ARGUMENT);
+        }
+        if ((instance != null) && !display.equals(instance.display)) {
+            throw new UnsupportedOperationException("Multiple displays not supported");
+        }
+        synchronized (AwtEnvironment.class) {
+            if (instance == null) {
+                instance = new AwtEnvironment(display);
+            }
+        }
+        return instance;
+    }
+
+    // Private constructor - clients use getInstance() to obtain instances
+    private AwtEnvironment(Display display) {
+        assert display != null;
+
+        /*
+         * This property removes a large amount of flicker from embedded swing
+         * components. Ideally it would not be set until EmbeddedSwingComposite
+         * is used, but since its value is read once and cached by AWT, it needs
+         * to be set before any AWT/Swing APIs are called.
+         */       
+        // TODO: this is effective only on Windows.
+        System.setProperty("sun.awt.noerasebackground", "true"); //$NON-NLS-1$//$NON-NLS-2$
+
+        /*
+         * RCP apps always want the standard platform look and feel It's
+         * important to wait for the L&F to be set so that any subsequent calls
+         * to createFrame() will be return a frame with the proper L&F (note
+         * that createFrame() happens on the SWT thread).
+         * 
+         * The call to invokeAndWait is safe because
+         * the first call AwtEnvironment.getInstance should happen
+         * before any (potential deadlocking) activity occurs on the 
+         * AWT thread.
+         */
+        try {
+            EventQueue.invokeAndWait(new Runnable() {
+                public void run() {
+                    setSystemLookAndFeel();
+                }
+            });
+        } catch (InterruptedException e) {
+            SWT.error(SWT.ERROR_FAILED_EXEC, e);
+        } catch (InvocationTargetException e) {
+            SWT.error(SWT.ERROR_FAILED_EXEC, e);
+        }
+
+        this.display = display;
+
+        // Listen for AWT modal dialogs to make them modal application-wide
+        dialogListener = new AwtDialogListener(display);
+    }
+
+    /**
+     * Invokes the given runnable in the AWT event thread while blocking user
+     * input on the SWT event thread. The SWT event thread will remain blocked
+     * until the runnable task completes, at which point this method will
+     * return.
+     * <p>
+     * This method is useful for displayng modal AWT/Swing dialogs from the SWT
+     * event thread. The modal AWT/Swing dialog will always block input across
+     * the whole application, but not until it appears. By calling this method,
+     * it is guaranteed that SWT input is blocked immediately, even before the
+     * AWT/Swing dialog appears.
+     * <p>
+     * To avoid unnecessary flicker, AWT/Swing dialogs should have their parent
+     * set to a frame returned by {@link #createDialogParentFrame()}.
+     * <p>
+     * This method must be called from the SWT event thread.
+     * 
+     * @param runnable
+     *            the code to schedule on the AWT event thread
+     * @exception IllegalArgumentException
+     *                <ul>
+     *                <li>ERROR_NULL_ARGUMENT - if the runnable is null</li>
+     *                </ul>
+     * @exception SWTException
+     *                <ul>
+     *                <li>ERROR_THREAD_INVALID_ACCESS - if not called from the
+     *                SWT event thread
+     *                </ul>
+     */
+    public void invokeAndBlockSwt(final Runnable runnable) {
+        assert display != null;
+
+        /*
+         * This code snippet is based on the following thread on
+         * news.eclipse.platform.swt:
+         * http://dev.eclipse.org/newslists/news.eclipse.platform.swt/msg24234.html
+         */
+        if (runnable == null) {
+            SWT.error(SWT.ERROR_NULL_ARGUMENT);
+        }
+        if (display != Display.getCurrent()) {
+            SWT.error(SWT.ERROR_THREAD_INVALID_ACCESS);
+        }
+
+        // Switch to the AWT thread...
+        EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                try {
+                    // do swing work...
+                    runnable.run();
+                } finally {
+                    display.asyncExec(new Runnable() {
+                        public void run() {
+                            // Unblock SWT
+                            SwtInputBlocker.unblock();
+                        }
+                    });
+                }
+            }
+        });
+
+        // Prevent user input on SWT components
+        SwtInputBlocker.block();
+    }
+
+    /**
+     * Creates an AWT frame suitable as a parent for AWT/Swing dialogs. 
+     * <p>
+     * This method must be called from the SWT event thread. There must be an active
+     * shell associated with the environment's display.  
+     * <p>
+     * The created frame is a non-visible child of the active shell and will be disposed when that shell
+     * is disposed.
+     * <p>
+     * See {@link #createDialogParentFrame(Shell)} for more details. 
+     * 
+     * @return a {@link java.awt.Frame} to be used for parenting dialogs
+     * @exception SWTException
+     *                <ul>
+     *                <li>ERROR_THREAD_INVALID_ACCESS - if not called from the
+     *                SWT event thread
+     *                </ul>
+     * @exception IllegalStateException
+     *                if the current display has no shells
+     */
+    public Frame createDialogParentFrame() {
+        if (display != Display.getCurrent()) {
+            SWT.error(SWT.ERROR_THREAD_INVALID_ACCESS);
+        }
+        Shell parent = display.getActiveShell();
+        if (parent == null) {
+            throw new IllegalStateException("No Active Shell");
+        }
+        return createDialogParentFrame(parent);
+    }
+    
+    /**
+     * Creates an AWT frame suitable as a parent for AWT/Swing dialogs. 
+     * <p>
+     * This method must be called from the SWT event thread. There must be an active
+     * shell associated with the environment's display.
+     * <p>
+     * The created frame is a non-visible child of the given shell and will be disposed when that shell
+     * is disposed.
+     * <p>
+     * This method is useful for creating a frame to parent any AWT/Swing
+     * dialogs created for use inside a SWT application. A modal AWT/Swing
+     * dialogs will flicker less if its parent is set to the returned frame
+     * rather than to null or to an independently created {@link java.awt.Frame}.  
+     * 
+     * @return a {@link java.awt.Frame} to be used for parenting dialogs
+     * @exception SWTException
+     *                <ul>
+     *                <li>ERROR_THREAD_INVALID_ACCESS - if not called from the
+     *                SWT event thread
+     *                </ul>
+     * @exception IllegalStateException
+     *                if the current display has no shells
+     */
+    public Frame createDialogParentFrame(Shell parent) {
+        if (parent == null) {
+            SWT.error(SWT.ERROR_NULL_ARGUMENT);
+        }
+        if (display != Display.getCurrent()) {
+            SWT.error(SWT.ERROR_THREAD_INVALID_ACCESS);
+        }
+        Shell shell = new Shell(parent);
+        shell.setVisible(false);
+        Composite composite = new Composite(shell, SWT.EMBEDDED);
+        return SWT_AWT.new_Frame(composite);
+    }
+
+    // Find a shell to use, giving preference to the active shell.
+    Shell getShell() {
+        Shell shell = display.getActiveShell();
+        if (shell == null) {
+            Shell[] allShells = display.getShells();
+            if (allShells.length > 0) {
+                shell = allShells[0];
+            }
+        }
+        return shell;
+    }
+
+    void requestAwtDialogFocus() {
+        assert dialogListener != null;
+
+        dialogListener.requestFocus();
+    }
+
+    private void setSystemLookAndFeel() {
+        assert EventQueue.isDispatchThread(); // On AWT event thread
+
+        if (!isLookAndFeelInitialized) {
+            isLookAndFeelInitialized = true;
+            try {
+                String systemLaf = UIManager.getSystemLookAndFeelClassName();
+                String xplatLaf = UIManager.getCrossPlatformLookAndFeelClassName();
+
+                // Java makes metal the system look and feel if running under a
+                // non-gnome Linux desktop. Fix that here, if the RCP itself is
+                // running
+                // with the GTK windowing system set.
+                if (xplatLaf.equals(systemLaf) && Platform.isGtk()) {
+                    systemLaf = GTK_LOOK_AND_FEEL_NAME;
+                }
+                UIManager.setLookAndFeel(systemLaf);
+            } catch (ClassNotFoundException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+            } catch (InstantiationException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+            } catch (IllegalAccessException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+            } catch (UnsupportedLookAndFeelException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+            }
+        }
+    }
+    
+    // This method is called by unit tests
+    static void reset() {
+        instance = null;
+    }
+
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/awt/AwtEnvironment.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/awt/RecursiveContainerListener.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/awt/RecursiveContainerListener.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/gui/swt/awt/RecursiveContainerListener.java	(revision 1041)
@@ -14,104 +14,104 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-/*******************************************************************************
- * Copyright (c) 2007 SAS Institute.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     SAS Institute - initial API and implementation
- *******************************************************************************/
-package org.pathvisio.gui.swt.awt;
-
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
 import java.awt.Component;
 import java.awt.Container;
 import java.awt.EventQueue;
 import java.awt.event.ContainerEvent;
 import java.awt.event.ContainerListener;
-
-class RecursiveContainerListener implements ContainerListener {
-    private final ContainerListener listener;
-    
-    RecursiveContainerListener(ContainerListener listener) {
-        assert listener != null;
-        
-        this.listener = listener;
-    }
-
-    private void handleAdd(Container source, Component c) {
-        assert source != null;
-        assert c != null;
-        assert listener != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        // System.out.println("Listening to: " + c);
-        listener.componentAdded(new ContainerEvent(source, ContainerEvent.COMPONENT_ADDED, c));
-        if (c instanceof Container) {
-            ((Container)c).addContainerListener(this);
-        }
-    }
-    
-    private void handleRemove(Container source, Component c) {
-        assert source != null;
-        assert c != null;
-        assert listener != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-
-        // System.out.println("Stopped Listening to: " + c);
-        listener.componentRemoved(new ContainerEvent(source, ContainerEvent.COMPONENT_REMOVED, c));
-        if (c instanceof Container) {
-            ((Container)c).removeContainerListener(this);
-        }
-    }
-    
-    private void handleAllAdds(Container source, Component child) {
-        assert source != null;
-        assert child != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-
-        if (child instanceof Container) {
-            Container container = (Container)child;
-            Component[] children = container.getComponents();
-            for (int i = 0; i < children.length; i++) {
-                handleAllAdds(container, children[i]);
-            }
-        }
-        handleAdd(source, child);
-    }
-    
-    private void handleAllRemoves(Container source, Component child) {
-        assert source != null;
-        assert child != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-
-        if (child instanceof Container) {
-            Container container = (Container)child;
-            Component[] children = container.getComponents();
-            for (int i = 0; i < children.length; i++) {
-                handleAllRemoves(container, children[i]);
-            }
-        }
-        handleRemove(source, child);
-
-    }
-
-    public void componentAdded(ContainerEvent e) {
-        assert e != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        Container source = (Container)e.getSource();
-        handleAllAdds(source, e.getChild());
-    }
-    
-    public void componentRemoved(ContainerEvent e) {
-        assert e != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        Container source = (Container)e.getSource();
-        handleAllRemoves(source, e.getChild());
-    }
-}
-
+
+class RecursiveContainerListener implements ContainerListener {
+    private final ContainerListener listener;
+    
+    RecursiveContainerListener(ContainerListener listener) {
+        assert listener != null;
+        
+        this.listener = listener;
+    }
+
+    private void handleAdd(Container source, Component c) {
+        assert source != null;
+        assert c != null;
+        assert listener != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("Listening to: " + c);
+        listener.componentAdded(new ContainerEvent(source, ContainerEvent.COMPONENT_ADDED, c));
+        if (c instanceof Container) {
+            ((Container)c).addContainerListener(this);
+        }
+    }
+    
+    private void handleRemove(Container source, Component c) {
+        assert source != null;
+        assert c != null;
+        assert listener != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+
+        // System.out.println("Stopped Listening to: " + c);
+        listener.componentRemoved(new ContainerEvent(source, ContainerEvent.COMPONENT_REMOVED, c));
+        if (c instanceof Container) {
+            ((Container)c).removeContainerListener(this);
+        }
+    }
+    
+    private void handleAllAdds(Container source, Component child) {
+        assert source != null;
+        assert child != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+
+        if (child instanceof Container) {
+            Container container = (Container)child;
+            Component[] children = container.getComponents();
+            for (int i = 0; i < children.length; i++) {
+                handleAllAdds(container, children[i]);
+            }
+        }
+        handleAdd(source, child);
+    }
+    
+    private void handleAllRemoves(Container source, Component child) {
+        assert source != null;
+        assert child != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+
+        if (child instanceof Container) {
+            Container container = (Container)child;
+            Component[] children = container.getComponents();
+            for (int i = 0; i < children.length; i++) {
+                handleAllRemoves(container, children[i]);
+            }
+        }
+        handleRemove(source, child);
+
+    }
+
+    public void componentAdded(ContainerEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        Container source = (Container)e.getSource();
+        handleAllAdds(source, e.getChild());
+    }
+    
+    public void componentRemoved(ContainerEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        Container source = (Container)e.getSource();
+        handleAllRemoves(source, e.getChild());
+    }
+}
+

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/awt/RecursiveContainerListener.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/awt/AwtDialogListener.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/awt/AwtDialogListener.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/gui/swt/awt/AwtDialogListener.java	(revision 1041)
@@ -14,18 +14,18 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-/*******************************************************************************
- * Copyright (c) 2007 SAS Institute.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     SAS Institute - initial API and implementation
- *******************************************************************************/
-package org.pathvisio.gui.swt.awt;
-
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
 import java.awt.AWTEvent;
 import java.awt.Dialog;
 import java.awt.EventQueue;
@@ -39,202 +39,202 @@
 import java.util.List;
 
 import org.eclipse.swt.widgets.Display;
-
-/**
- * A listener that insures the proper modal behavior of Swing dialogs when running
- * within a SWT environment. When initialized, it blocks and unblocks SWT input
- * as modal Swing dialogs are shown and hidden. 
- */
-class AwtDialogListener implements AWTEventListener, ComponentListener {
-    
-    // modalDialogs should be accessed only from the AWT thread, so no
-    // synchronization is needed. 
-    private final List modalDialogs = new ArrayList();
-    private final Display display;
-    
-    /**
-     * Registers this object as an AWT event listener so that Swing dialogs have the 
-     * proper modal behavior in the containing SWT environment. This is called automatically
-     * when you construct a {@link EmbeddedSwingComposite}, and it
-     * need not be called separately in that case.  
-     * @param shell 
-     */
-    AwtDialogListener(Display display) {
-        assert display != null;
-        
-        this.display = display;
-        Toolkit.getDefaultToolkit().addAWTEventListener(this, AWTEvent.WINDOW_EVENT_MASK);
-    }
-    
-    private void handleRemovedDialog(Dialog awtDialog, boolean removeListener) {
-        assert awtDialog != null;
-        assert modalDialogs != null;
-        assert display != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        // System.out.println("Remove dialog: " + awtDialog);
-        if (removeListener) {
-            awtDialog.removeComponentListener(this);
-        }
-        // Note: there is no isModal() check here because the dialog might 
-        // have been changed from modal to non-modal after it was opened. In this case
-        // the currently visible dialog would still act modal and we'd need to unblock
-        // SWT here when it goes away.
-        if (modalDialogs.remove(awtDialog)) {
-            display.asyncExec(new Runnable() {
-                public void run() {
-                    SwtInputBlocker.unblock();
-                }
-            });            
-        }
-    }
-
-    private void handleAddedDialog(final Dialog awtDialog) {
-        assert awtDialog != null;
-        assert modalDialogs != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        // System.out.println("Add dialog: " + awtDialog);
-        if (modalDialogs.contains(awtDialog) || !awtDialog.isModal() || !awtDialog.isVisible()) {
-            return;
-        }
-        modalDialogs.add(awtDialog);
-        awtDialog.addComponentListener(this);
-        display.asyncExec(new Runnable() {
-            public void run() {
-                SwtInputBlocker.block();
-            }
-        });        
-    }
-    
-    void requestFocus() {
-        // TODO: this does not always bring the dialog to the top 
-        // under some Linux desktops/window managers (e.g. metacity under GNOME).
-        EventQueue.invokeLater(new Runnable() {
-            public void run() {
-                assert modalDialogs != null;
-                
-                int size = modalDialogs.size();
-                if (size > 0) {
-                    final Dialog awtDialog = (Dialog)modalDialogs.get(size - 1);
-
-                    // In one case, a call to requestFocus() alone does not 
-                    // bring the AWT dialog to the top. This happens if the 
-                    // dialog is given a null parent frame. When opened, the dialog
-                    // can be hidden by the SWT window even when it obtains focus.
-                    // Calling toFront() solves the problem, but...
-                    //
-                    // There are still problems if the Metal look and feel is in use.
-                    // The SWT window will hide the dialog the first time it is 
-                    // selected. Once the dialog is brought back to the front by 
-                    // the user, there is no further problem. 
-                    //
-                    // Why? It looks like SWT is not being notified of lost focus when 
-                    // the Metal dialog first opens; subsequently, when focus is regained, the 
-                    // focus gain event is not posted to the SwtInputBlocker.  
-                    //
-                    // The workaround is to use Windows look and feel, rather than Metal.
-                    // System.out.println("Bringing to front");
-
-                    awtDialog.requestFocus();
-                    awtDialog.toFront();
-                }
-            }
-        });
-    }
-
-    private void handleOpenedWindow(WindowEvent event) {
-        assert event != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        Window window = event.getWindow();
-        if (window instanceof Dialog) {
-            handleAddedDialog((Dialog)window);
-        }
-    }
-    
-    private void handleClosedWindow(WindowEvent event) {
-        assert event != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        // Dispose-based close
-        Window window = event.getWindow();
-        if (window instanceof Dialog) {
-            // Remove dialog and component listener
-            handleRemovedDialog((Dialog)window, true);
-        }
-    }
-
-    private void handleClosingWindow(WindowEvent event) {
-        assert event != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        // System-based close 
-        Window window = event.getWindow();
-        if (window instanceof Dialog) {
-            final Dialog dialog = (Dialog) window;
-            // Defer until later. Bad things happen if 
-            // handleRemovedDialog() is called directly from 
-            // this event handler. The Swing dialog does not close
-            // properly and its modality remains in effect.
-            EventQueue.invokeLater(new Runnable() {
-                public void run() {
-                    // Remove dialog and component listener
-                    handleRemovedDialog(dialog, true);
-                }
-            });
-        }
-    }
-    
-    public void eventDispatched(AWTEvent event) {
-        assert event != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        switch (event.getID()) {
-        case WindowEvent.WINDOW_OPENED:
-            handleOpenedWindow((WindowEvent)event);
-            break;
-            
-        case WindowEvent.WINDOW_CLOSED:
-            handleClosedWindow((WindowEvent)event);
-            break;
-
-        case WindowEvent.WINDOW_CLOSING:
-            handleClosingWindow((WindowEvent)event);
-            break;
-
-        default:
-            break;
-        }
-    }
-
-    public void componentHidden(ComponentEvent e) {
-        assert e != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        // System.out.println("Component hidden");
-        Object obj = e.getSource();
-        if (obj instanceof Dialog) {
-            // Remove dialog but keep listener in place so that we know if/when it is set visible
-            handleRemovedDialog((Dialog)obj, false);
-        }
-    }
-
-    public void componentShown(ComponentEvent e) {
-        assert e != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        // System.out.println("Component shown");
-        Object obj = e.getSource();
-        if (obj instanceof Dialog) {
-            handleAddedDialog((Dialog)obj);
-        }
-    }
-
-    public void componentResized(ComponentEvent e) {
-    }
-
-    public void componentMoved(ComponentEvent e) {
-    }
-        
-}
+
+/**
+ * A listener that insures the proper modal behavior of Swing dialogs when running
+ * within a SWT environment. When initialized, it blocks and unblocks SWT input
+ * as modal Swing dialogs are shown and hidden. 
+ */
+class AwtDialogListener implements AWTEventListener, ComponentListener {
+    
+    // modalDialogs should be accessed only from the AWT thread, so no
+    // synchronization is needed. 
+    private final List modalDialogs = new ArrayList();
+    private final Display display;
+    
+    /**
+     * Registers this object as an AWT event listener so that Swing dialogs have the 
+     * proper modal behavior in the containing SWT environment. This is called automatically
+     * when you construct a {@link EmbeddedSwingComposite}, and it
+     * need not be called separately in that case.  
+     * @param shell 
+     */
+    AwtDialogListener(Display display) {
+        assert display != null;
+        
+        this.display = display;
+        Toolkit.getDefaultToolkit().addAWTEventListener(this, AWTEvent.WINDOW_EVENT_MASK);
+    }
+    
+    private void handleRemovedDialog(Dialog awtDialog, boolean removeListener) {
+        assert awtDialog != null;
+        assert modalDialogs != null;
+        assert display != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("Remove dialog: " + awtDialog);
+        if (removeListener) {
+            awtDialog.removeComponentListener(this);
+        }
+        // Note: there is no isModal() check here because the dialog might 
+        // have been changed from modal to non-modal after it was opened. In this case
+        // the currently visible dialog would still act modal and we'd need to unblock
+        // SWT here when it goes away.
+        if (modalDialogs.remove(awtDialog)) {
+            display.asyncExec(new Runnable() {
+                public void run() {
+                    SwtInputBlocker.unblock();
+                }
+            });            
+        }
+    }
+
+    private void handleAddedDialog(final Dialog awtDialog) {
+        assert awtDialog != null;
+        assert modalDialogs != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("Add dialog: " + awtDialog);
+        if (modalDialogs.contains(awtDialog) || !awtDialog.isModal() || !awtDialog.isVisible()) {
+            return;
+        }
+        modalDialogs.add(awtDialog);
+        awtDialog.addComponentListener(this);
+        display.asyncExec(new Runnable() {
+            public void run() {
+                SwtInputBlocker.block();
+            }
+        });        
+    }
+    
+    void requestFocus() {
+        // TODO: this does not always bring the dialog to the top 
+        // under some Linux desktops/window managers (e.g. metacity under GNOME).
+        EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                assert modalDialogs != null;
+                
+                int size = modalDialogs.size();
+                if (size > 0) {
+                    final Dialog awtDialog = (Dialog)modalDialogs.get(size - 1);
+
+                    // In one case, a call to requestFocus() alone does not 
+                    // bring the AWT dialog to the top. This happens if the 
+                    // dialog is given a null parent frame. When opened, the dialog
+                    // can be hidden by the SWT window even when it obtains focus.
+                    // Calling toFront() solves the problem, but...
+                    //
+                    // There are still problems if the Metal look and feel is in use.
+                    // The SWT window will hide the dialog the first time it is 
+                    // selected. Once the dialog is brought back to the front by 
+                    // the user, there is no further problem. 
+                    //
+                    // Why? It looks like SWT is not being notified of lost focus when 
+                    // the Metal dialog first opens; subsequently, when focus is regained, the 
+                    // focus gain event is not posted to the SwtInputBlocker.  
+                    //
+                    // The workaround is to use Windows look and feel, rather than Metal.
+                    // System.out.println("Bringing to front");
+
+                    awtDialog.requestFocus();
+                    awtDialog.toFront();
+                }
+            }
+        });
+    }
+
+    private void handleOpenedWindow(WindowEvent event) {
+        assert event != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        Window window = event.getWindow();
+        if (window instanceof Dialog) {
+            handleAddedDialog((Dialog)window);
+        }
+    }
+    
+    private void handleClosedWindow(WindowEvent event) {
+        assert event != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // Dispose-based close
+        Window window = event.getWindow();
+        if (window instanceof Dialog) {
+            // Remove dialog and component listener
+            handleRemovedDialog((Dialog)window, true);
+        }
+    }
+
+    private void handleClosingWindow(WindowEvent event) {
+        assert event != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System-based close 
+        Window window = event.getWindow();
+        if (window instanceof Dialog) {
+            final Dialog dialog = (Dialog) window;
+            // Defer until later. Bad things happen if 
+            // handleRemovedDialog() is called directly from 
+            // this event handler. The Swing dialog does not close
+            // properly and its modality remains in effect.
+            EventQueue.invokeLater(new Runnable() {
+                public void run() {
+                    // Remove dialog and component listener
+                    handleRemovedDialog(dialog, true);
+                }
+            });
+        }
+    }
+    
+    public void eventDispatched(AWTEvent event) {
+        assert event != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        switch (event.getID()) {
+        case WindowEvent.WINDOW_OPENED:
+            handleOpenedWindow((WindowEvent)event);
+            break;
+            
+        case WindowEvent.WINDOW_CLOSED:
+            handleClosedWindow((WindowEvent)event);
+            break;
+
+        case WindowEvent.WINDOW_CLOSING:
+            handleClosingWindow((WindowEvent)event);
+            break;
+
+        default:
+            break;
+        }
+    }
+
+    public void componentHidden(ComponentEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("Component hidden");
+        Object obj = e.getSource();
+        if (obj instanceof Dialog) {
+            // Remove dialog but keep listener in place so that we know if/when it is set visible
+            handleRemovedDialog((Dialog)obj, false);
+        }
+    }
+
+    public void componentShown(ComponentEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("Component shown");
+        Object obj = e.getSource();
+        if (obj instanceof Dialog) {
+            handleAddedDialog((Dialog)obj);
+        }
+    }
+
+    public void componentResized(ComponentEvent e) {
+    }
+
+    public void componentMoved(ComponentEvent e) {
+    }
+        
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/awt/AwtDialogListener.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/awt/EmbeddedChildFocusTraversalPolicy.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/awt/EmbeddedChildFocusTraversalPolicy.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/gui/swt/awt/EmbeddedChildFocusTraversalPolicy.java	(revision 1041)
@@ -14,96 +14,96 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-/*******************************************************************************
- * Copyright (c) 2007 SAS Institute.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     SAS Institute - initial API and implementation
- *******************************************************************************/
-package org.pathvisio.gui.swt.awt;
-
-
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
+
 import java.awt.Component;
 import java.awt.Container;
 import java.awt.EventQueue;
 
 import javax.swing.LayoutFocusTraversalPolicy;
-
-class EmbeddedChildFocusTraversalPolicy extends LayoutFocusTraversalPolicy {
-
-    private static final long serialVersionUID = -7708166698501335927L;
-    private final AwtFocusHandler awtHandler;
-
-     EmbeddedChildFocusTraversalPolicy(AwtFocusHandler handler) {
-         assert handler != null;
-         awtHandler = handler;
-    }
-
-    public Component getComponentAfter(Container container, Component component) {
-        assert container != null;
-        assert component != null;
-        assert awtHandler != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        if (component.equals(getLastComponent(container))) {
-            // Instead of cycling around to the first component, transfer to the next SWT component
-            awtHandler.transferFocusNext();
-            return null;
-        } else {
-            return super.getComponentAfter(container, component);
-        }
-    }
-
-    public Component getComponentBefore(Container container, Component component) {
-        assert container != null;
-        assert component != null;
-        assert awtHandler != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        if (component.equals(getFirstComponent(container))) {
-            // Instead of cycling around to the last component, transfer to the previous SWT component
-            awtHandler.transferFocusPrevious();
-            return null;
-        } else {
-            return super.getComponentBefore(container, component);
-        }
-    }
-    
-    public Component getDefaultComponent(Container container) {
-        assert container != null;
-        assert awtHandler != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        // This is a hack which depends on knowledge of current JDK implementation to 
-        // work. The implementation above of getComponentBefore/After
-        // properly returns null when transferring to SWT. However, the calling AWT container
-        // will then immediately try this method to find the next recipient of
-        // focus. But we don't want *any* AWT component to receive focus... it's just
-        // been transferred to SWT. So, this method must return null when AWT does 
-        // not own the focus. When AWT *does* own the focus, behave normally.  
-        if (awtHandler.awtHasFocus()) {
-            // System.out.println("getDefault: super");
-            return super.getDefaultComponent(container);
-        } else {
-            // System.out.println("getDefault: null");
-            return null;
-        }
-    }
-
-    public Component getCurrentComponent(Container container) {
-        assert container != null;
-        assert awtHandler != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        Component currentAwtComponent = awtHandler.getCurrentComponent();
-        if ((currentAwtComponent != null) && container.isAncestorOf(currentAwtComponent)){
-            return currentAwtComponent;
-        } else {
-            return getDefaultComponent(container);
-        }
-    }
-}
+
+class EmbeddedChildFocusTraversalPolicy extends LayoutFocusTraversalPolicy {
+
+    private static final long serialVersionUID = -7708166698501335927L;
+    private final AwtFocusHandler awtHandler;
+
+     EmbeddedChildFocusTraversalPolicy(AwtFocusHandler handler) {
+         assert handler != null;
+         awtHandler = handler;
+    }
+
+    public Component getComponentAfter(Container container, Component component) {
+        assert container != null;
+        assert component != null;
+        assert awtHandler != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        if (component.equals(getLastComponent(container))) {
+            // Instead of cycling around to the first component, transfer to the next SWT component
+            awtHandler.transferFocusNext();
+            return null;
+        } else {
+            return super.getComponentAfter(container, component);
+        }
+    }
+
+    public Component getComponentBefore(Container container, Component component) {
+        assert container != null;
+        assert component != null;
+        assert awtHandler != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        if (component.equals(getFirstComponent(container))) {
+            // Instead of cycling around to the last component, transfer to the previous SWT component
+            awtHandler.transferFocusPrevious();
+            return null;
+        } else {
+            return super.getComponentBefore(container, component);
+        }
+    }
+    
+    public Component getDefaultComponent(Container container) {
+        assert container != null;
+        assert awtHandler != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // This is a hack which depends on knowledge of current JDK implementation to 
+        // work. The implementation above of getComponentBefore/After
+        // properly returns null when transferring to SWT. However, the calling AWT container
+        // will then immediately try this method to find the next recipient of
+        // focus. But we don't want *any* AWT component to receive focus... it's just
+        // been transferred to SWT. So, this method must return null when AWT does 
+        // not own the focus. When AWT *does* own the focus, behave normally.  
+        if (awtHandler.awtHasFocus()) {
+            // System.out.println("getDefault: super");
+            return super.getDefaultComponent(container);
+        } else {
+            // System.out.println("getDefault: null");
+            return null;
+        }
+    }
+
+    public Component getCurrentComponent(Container container) {
+        assert container != null;
+        assert awtHandler != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        Component currentAwtComponent = awtHandler.getCurrentComponent();
+        if ((currentAwtComponent != null) && container.isAncestorOf(currentAwtComponent)){
+            return currentAwtComponent;
+        } else {
+            return getDefaultComponent(container);
+        }
+    }
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/awt/EmbeddedChildFocusTraversalPolicy.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/awt/EmbeddedSwingComposite.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/awt/EmbeddedSwingComposite.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/gui/swt/awt/EmbeddedSwingComposite.java	(revision 1041)
@@ -14,18 +14,18 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-/*******************************************************************************
- * Copyright (c) 2007 SAS Institute.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     SAS Institute - initial API and implementation
- *******************************************************************************/
-package org.pathvisio.gui.swt.awt;
-
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
 import java.awt.Container;
 import java.awt.EventQueue;
 import java.awt.Frame;
@@ -49,448 +49,448 @@
 import org.eclipse.swt.widgets.Event;
 import org.eclipse.swt.widgets.Listener;
 import org.eclipse.swt.widgets.Widget;
-
-/**
- * A SWT composite widget for embedding Swing components in a SWT composite within an RCP or standalone-SWT application. The Eclipse platform 
- * provides limited support for embedding Swing components through {@link org.eclipse.swt.awt.SWT_AWT}. 
- * This class extends that support by 
- * <ul>
- * <li>Using the platform-specific system Look and Feel. 
- * <li>Ensuring AWT modal dialogs are modal across the SWT application.
- * <li>Reducing flicker, especially on window resizes
- * <li>Allowing Tab Traversal to and from the Embedded Frame
- * <li>Dismissing most Pop-Up Menus when focus leaves the AWT frame.  
- * <li>Synchronizing Font Changes from system settings
- * <li>Working around various AWT/Swing bugs  
- * </ul>
- * <P>
- * If, rather than embedding Swing components, you are integrating with Swing by opening 
- * Swing dialogs, see the {@link AwtEnvironment} class. 
- * <p>
- * This is an abstract that is normally used by extending it and implementing the {@link #createSwingComponent()} method. For example,  
- * <pre>
- *        embeddedComposite = new EmbeddedSwingComposite(parent, SWT.NONE) {
- *            protected JComponent createSwingComponent() {
- *                scrollPane = new JScrollPane();
- *                table = new JTable();
- *                scrollPane.setViewportView(table);
- *                return scrollPane;
- *            }
- *        }; 
- *        embeddedComposite.populate();
- * </pre>
- * <p>
- * The Swing component is created inside a standard Swing containment hierarchy, rooted in 
- * a {@link javax.swing.RootPaneContainer}. The root pane container is placed inside an AWT frame, as
- * returned by {@link org.eclipse.swt.awt.SWT_AWT#new_Frame(Composite)} 
- * <p>
- * <b>Note:</b> When you mix components from Swing/AWT and SWT toolkits, there will be two UI event threads,
- * one for AWT, one for SWT. Most SWT APIs require that you call them from the SWT thread. Swing 
- * has similar restrictions though it does not enforce them as much as SWT.
- * <p>
- * Applications need to be aware of the current thread, and, where necessary, schedule tasks to run 
- * on another thread. This has always been required in the pure Swing or SWT environments, but when 
- * mixing Swing and SWT, more of this scheduling will be necessary.
- * <p>
- * To schedule work on the AWT event 
- * thread, you can use:
- * <ul>
- * <li>{@link javax.swing.SwingUtilities#invokeLater(Runnable)}
- * <li>{@link javax.swing.SwingUtilities#invokeAndWait(Runnable)} 
- * </ul>
- * <p>
- * (or similar methods in {@link java.awt.EventQueue})
- * <p>
- * To schedule work on the SWT event thread, use:
- * <ul>
- * <li>{@link org.eclipse.swt.widgets.Display#asyncExec(Runnable)}
- * <li>{@link org.eclipse.swt.widgets.Display#syncExec(Runnable)}
- * </ul>
- * 
- * Of course, as in single-toolkit environments, long-running tasks should be offloaded from either UI 
- * thread to a background thread. The Eclipse jobs API can be used for this purpose.
- */
-public abstract class EmbeddedSwingComposite extends Composite {
-    private static class AwtContext {
-        private Frame frame;
-        private JComponent swingComponent;
-        
-        AwtContext(Frame frame) {
-            assert frame != null;
-            this.frame = frame;
-        }
-
-        Frame getFrame() {
-            return frame;
-        }
-
-        void setSwingComponent(JComponent swingComponent) {
-            this.swingComponent = swingComponent;
-        }
-
-        JComponent getSwingComponent() {
-            return swingComponent;
-        }
-        
-    }
-    private Font currentSystemFont;
-    private AwtContext awtContext;
-    private AwtFocusHandler awtHandler;
-
-    private Listener settingsListener = new Listener() {
-        public void handleEvent(Event event) {
-            handleSettingsChange();
-        }
-    };
-    
-    // This listener helps ensure that Swing popup menus are properly dismissed when
-    // a menu item off the SWT main menu bar is shown.
-    private final Listener menuListener = new Listener() {
-        public void handleEvent(Event event) {
-            assert awtHandler != null;
-            
-            awtHandler.postHidePopups();
-        }
-    };
-    
-    /**
-     * Constructs a new instance of this class given its parent
-     * and a style value describing its behavior and appearance.
-     * <p>
-     * This method must be called from the SWT event thread. 
-     * <p>
-     * The style value is either one of the style constants defined in
-     * class <code>SWT</code> which is applicable to instances of this
-     * class, or must be built by <em>bitwise OR</em>'ing together 
-     * (that is, using the <code>int</code> "|" operator) two or more
-     * of those <code>SWT</code> style constants. The class description
-     * lists the style constants that are applicable to the class.
-     * Style bits are also inherited from superclasses.
-     * </p>
-     * <p>
-     * The styles SWT.EMBEDDED and SWT.NO_BACKGROUND will be added
-     * to the specified style. Usually, no other style bits are needed.
-     *
-     * @param parent a widget which will be the parent of the new instance (cannot be null)
-     * @param style the style of widget to construct
-     *
-     * @exception IllegalArgumentException <ul>
-     *    <li>ERROR_NULL_ARGUMENT - if the parent is null</li>
-     * </ul>
-     * @exception SWTException <ul>
-     *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the SWT event thread
-     * </ul>
-     *
-     * @see Widget#getStyle
-     */
-    public EmbeddedSwingComposite(Composite parent, int style) {
-        super(parent, style | SWT.EMBEDDED | SWT.NO_BACKGROUND);
-        getDisplay().addListener(SWT.Settings, settingsListener);
-        setLayout(new FillLayout());
-        currentSystemFont = getFont();
-    }
-
-    /**
-     * Populates the embedded composite with the Swing component.
-     * <p> 
-     * This method must be called from the
-     * SWT event thread.  
-     * <p>
-     * The Swing component will be created by calling {@link #createSwingComponent()}. The creation is
-     * scheduled asynchronously on the AWT event thread. This method does not wait for completion of this
-     * asynchronous task, so it may return before createSwingComponent() is complete.   
-     * <p>
-     * The Swing component is created inside a standard Swing containment hierarchy, rooted in 
-     * a {@link javax.swing.RootPaneContainer}. Clients can override {@link #addRootPaneContainer(Frame)}
-     * to provide their own root pane container implementation.
-     * <p>
-     * This method can be called multiple times for a single instance. If an embedded frame exists from 
-     * a previous call, it is disposed.
-     *  
-     * @exception SWTException <ul>
-     *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
-     *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the SWT event thread
-     * </ul>
-     */
-    public void populate() {
-        checkWidget();
-        createFrame();
-        scheduleComponentCreation();
-    }
-
-    /**
-     * Creates the embedded Swing component. This method is called from the AWT event thread. 
-     * <p> 
-     * Implement this method to provide the Swing component that will be shown inside this composite.
-     * The returned component will be added to the Swing content pane. At least one component must
-     * be created by this method; null is not a valid return value.   
-     *   
-     * @return a non-null Swing component
-     */
-    protected abstract JComponent createSwingComponent();
-    
-    /**
-     * Adds a root pane container to the embedded AWT frame. Override this to provide your own 
-     * {@link javax.swing.RootPaneContainer} implementation. In most cases, it is not necessary
-     * to override this method.    
-     * <p>
-     * This method is called from the AWT event thread. 
-     * <p> 
-     * If you are defining your own root pane container, make sure that there is at least one
-     * heavyweight (AWT) component in the frame's containment hierarchy; otherwise, event 
-     * processing will not work correctly. See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4982522
-     * for more information.  
-     *   
-     * @param frame the frame to which the root pane container is added 
-     * @return a non-null Swing component
-     */
-    protected RootPaneContainer addRootPaneContainer(Frame frame) {
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        assert frame != null;
-        
-        // It is important to set up the proper top level components in the frame:
-        // 1) For Swing to work properly, Sun documents that there must be an implementor of 
-        // javax.swing.RootPaneContainer at the top of the component hierarchy. 
-        // 2) For proper event handling there must be a heavyweight 
-        // an AWT frame must contain a heavyweight component (see 
-        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4982522)
-        // 3) The Swing implementation further narrows the options by expecting that the 
-        // top of the hierarchy be a JFrame, JDialog, JWindow, or JApplet. See javax.swing.PopupFactory.
-        // All this drives the choice of JApplet for the top level Swing component. It is the 
-        // only single component that satisfies all the above. This does not imply that 
-        // we have a true applet; in particular, there is no notion of an applet lifecycle in this
-        // context. 
-        JApplet applet = new JApplet();
-        
-        // In JRE 1.4, the JApplet makes itself a focus cycle root. This
-        // interferes with the focus handling installed on the parent frame, so
-        // change it back to a non-root here. 
-        // TODO: consider moving the focus policy from the Frame down to the JApplet
-        applet.setFocusCycleRoot(false);
-
-        frame.add(applet);
-        
-        return applet;
-    }
-
-    /**
-     * Performs custom updates to newly set fonts. This method is called whenever a change
-     * to the system font through the system settings (i.e. control panel) is detected.
-     * <p>
-     * This method is called from the AWT event thread.  
-     * <p>
-     * In most cases it is not necessary to override this method.  Normally, the implementation
-     * of this class will automatically propogate font changes to the embedded Swing components 
-     * through Swing's Look and Feel support. However, if additional 
-     * special processing is necessary, it can be done inside this method. 
-     *    
-     * @param newFont New AWT font
-     */
-    protected void updateAwtFont(java.awt.Font newFont) {
-    }
-
-    /**
-     * Returns the embedded AWT frame. The returned frame is the root of the AWT containment
-     * hierarchy for the embedded Swing component. This method can be called from 
-     * any thread. 
-     *    
-     * @return the embedded frame
-     */
-    public Frame getFrame() {
-        // Intentionally leaving out checkWidget() call. This may need to be called from within user's 
-        // createSwingComponent() method. Accessing from a non-SWT thread is OK, but we still check
-        // for disposal
-        if (getDisplay() == null || isDisposed()) {
-            SWT.error(SWT.ERROR_WIDGET_DISPOSED);            
-        }
-        
-        return (awtContext != null) ? awtContext.getFrame() : null;
-    }
-
-    private void createFrame() {
-        assert Display.getCurrent() != null;     // On SWT event thread
-        
-        // Make sure Awt environment is initialized. 
-        AwtEnvironment.getInstance(getDisplay());
-        
-        if (awtContext != null) {
-            final Frame oldFrame = awtContext.getFrame();
-            // Schedule disposal of old frame on AWT thread so that there are no problems with
-            // already-scheduled operations that have not completed.
-            // Note: the implementation of Frame.dispose() would schedule the use of the AWT 
-            // thread even if it was not done here, but it uses invokeAndWait() which is 
-            // prone to deadlock (and not necessary for this case). 
-            EventQueue.invokeLater(new Runnable() {
-                public void run() {
-                    oldFrame.dispose();
-                }
-            });
-        }
-        Frame frame = SWT_AWT.new_Frame(this);
-        awtContext = new AwtContext(frame);
-
-        // Glue the two frameworks together. Do this before anything is added to the frame
-        // so that all necessary listeners are in place.
-        createFocusHandlers();
-        
-        // This listener clears garbage during resizing, making it looker much cleaner 
-        addControlListener(new CleanResizeListener());
-    }
-
-    private void createFocusHandlers() {
-        assert awtContext != null;
-        assert Display.getCurrent() != null;     // On SWT event thread
-        
-        Frame frame = awtContext.getFrame();
-        awtHandler = new AwtFocusHandler(frame);   
-        SwtFocusHandler swtHandler = new SwtFocusHandler(this);
-        awtHandler.setSwtHandler(swtHandler);
-        swtHandler.setAwtHandler(awtHandler);
-        
-        // Ensure that AWT popups are dimissed whenever a SWT menu is shown
-        getDisplay().addFilter(SWT.Show, menuListener);
-        
-        EmbeddedChildFocusTraversalPolicy policy = new EmbeddedChildFocusTraversalPolicy(awtHandler);
-        frame.setFocusTraversalPolicy(policy);
-    }
-    
-    private void scheduleComponentCreation() {
-        assert awtContext != null;
-        
-        // Create AWT/Swing components on the AWT thread. This is 
-        // especially necessary to avoid an AWT leak bug (6411042).
-        final AwtContext currentContext = awtContext;
-        EventQueue.invokeLater(new Runnable() {
-            public void run() {
-                
-                RootPaneContainer container = addRootPaneContainer(currentContext.getFrame());
-                JComponent swingComponent = createSwingComponent();
-                currentContext.setSwingComponent(swingComponent);
-                container.getRootPane().getContentPane().add(swingComponent);
-                setComponentFont();
-            }
-        });
-    }
-
-    private void setComponentFont() {
-        assert currentSystemFont != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        JComponent swingComponent = (awtContext != null) ? awtContext.getSwingComponent() : null;
-        if ((swingComponent != null) && !currentSystemFont.getDevice().isDisposed()) {
-            FontData fontData = currentSystemFont.getFontData()[0];
-            
-            // AWT font sizes assume a 72 dpi resolution, always. The true screen resolution must be 
-            // used to convert the platform font size into an AWT point size that matches when displayed. 
-            int resolution = Toolkit.getDefaultToolkit().getScreenResolution();
-            int awtFontSize = (int)Math.round((double)fontData.getHeight() * resolution / 72.0);
-            
-            // The style constants for SWT and AWT map exactly, and since they are int constants, they should
-            // never change. So, the SWT style is passed through as the AWT style. 
-            java.awt.Font awtFont = new java.awt.Font(fontData.getName(), fontData.getStyle(), awtFontSize);
-
-            // Update the look and feel defaults to use new font.
-            updateLookAndFeel(awtFont);
-
-            // Allow subclasses to react to font change if necessary. 
-            updateAwtFont(awtFont);
-
-            // Allow components to update their UI based on new font 
-            // TODO: should the update method be called on the root pane instead?
-            Container contentPane = swingComponent.getRootPane().getContentPane();
-            SwingUtilities.updateComponentTreeUI(contentPane);
-        }
-    }
-    
-    private void updateLookAndFeel(java.awt.Font awtFont) {
-        assert awtFont != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        // The FontUIResource class marks the font as replaceable by the look and feel 
-        // implementation if font settings are later changed. 
-        FontUIResource fontResource = new FontUIResource(awtFont);
-
-        // Assign the new font to the relevant L&F font properties. These are 
-        // the properties that are initially assigned to the system font
-        // under the Windows look and feel. 
-        // TODO: It's possible that other platforms will need other assignments.
-        // TODO: This does not handle fonts other than the "system" font. 
-        // Other fonts may change, and the Swing L&F may not be adjusting.
-        
-        UIManager.put("Button.font", fontResource); //$NON-NLS-1$
-        UIManager.put("CheckBox.font", fontResource); //$NON-NLS-1$
-        UIManager.put("ComboBox.font", fontResource); //$NON-NLS-1$
-        UIManager.put("EditorPane.font", fontResource); //$NON-NLS-1$
-        UIManager.put("Label.font", fontResource); //$NON-NLS-1$
-        UIManager.put("List.font", fontResource); //$NON-NLS-1$
-        UIManager.put("Panel.font", fontResource); //$NON-NLS-1$
-        UIManager.put("ProgressBar.font", fontResource); //$NON-NLS-1$
-        UIManager.put("RadioButton.font", fontResource); //$NON-NLS-1$
-        UIManager.put("ScrollPane.font", fontResource); //$NON-NLS-1$
-        UIManager.put("TabbedPane.font", fontResource); //$NON-NLS-1$
-        UIManager.put("Table.font", fontResource); //$NON-NLS-1$
-        UIManager.put("TableHeader.font", fontResource); //$NON-NLS-1$
-        UIManager.put("TextField.font", fontResource); //$NON-NLS-1$
-        UIManager.put("TextPane.font", fontResource); //$NON-NLS-1$
-        UIManager.put("TitledBorder.font", fontResource); //$NON-NLS-1$
-        UIManager.put("ToggleButton.font", fontResource); //$NON-NLS-1$
-        UIManager.put("TreeFont.font", fontResource); //$NON-NLS-1$
-        UIManager.put("ViewportFont.font", fontResource); //$NON-NLS-1$
-    }
-
-    private void handleSettingsChange() {
-        Font newFont = getDisplay().getSystemFont();
-        if (!newFont.equals(currentSystemFont)) { 
-            currentSystemFont = newFont;
-            EventQueue.invokeLater(new Runnable() {
-                public void run() {
-                    setComponentFont();
-                }
-            });            
-        }
-    }
-
-    private boolean isFocusable() {
-        if (awtContext == null) {
-            return false;
-        }
-        JComponent swingComponent = awtContext.getSwingComponent();
-        return (swingComponent != null) && swingComponent.isFocusable(); 
-    }
-
-    /* (non-Javadoc)
-     * @see org.eclipse.swt.widgets.Control#setFocus()
-     */
-    public boolean setFocus() {
-        checkWidget();
-        
-        if (!isFocusable()) {
-            return false;
-        }
-        return super.setFocus();
-    }
-
-    /* (non-Javadoc)
-     * @see org.eclipse.swt.widgets.Control#forceFocus()
-     */
-    public boolean forceFocus() {
-        checkWidget();
-        
-        if (!isFocusable()) {
-            return false;
-        }
-        return super.forceFocus();
-    }
-
-    /* (non-Javadoc)
-     * @see org.eclipse.swt.widgets.Widget#dispose()
-     */
-    public void dispose() {
-        if (!isDisposed()) {
-            getDisplay().removeListener(SWT.Settings, settingsListener);
-            getDisplay().removeFilter(SWT.Show, menuListener);
-            super.dispose();
-        }
-    }
-    
-}
+
+/**
+ * A SWT composite widget for embedding Swing components in a SWT composite within an RCP or standalone-SWT application. The Eclipse platform 
+ * provides limited support for embedding Swing components through {@link org.eclipse.swt.awt.SWT_AWT}. 
+ * This class extends that support by 
+ * <ul>
+ * <li>Using the platform-specific system Look and Feel. 
+ * <li>Ensuring AWT modal dialogs are modal across the SWT application.
+ * <li>Reducing flicker, especially on window resizes
+ * <li>Allowing Tab Traversal to and from the Embedded Frame
+ * <li>Dismissing most Pop-Up Menus when focus leaves the AWT frame.  
+ * <li>Synchronizing Font Changes from system settings
+ * <li>Working around various AWT/Swing bugs  
+ * </ul>
+ * <P>
+ * If, rather than embedding Swing components, you are integrating with Swing by opening 
+ * Swing dialogs, see the {@link AwtEnvironment} class. 
+ * <p>
+ * This is an abstract that is normally used by extending it and implementing the {@link #createSwingComponent()} method. For example,  
+ * <pre>
+ *        embeddedComposite = new EmbeddedSwingComposite(parent, SWT.NONE) {
+ *            protected JComponent createSwingComponent() {
+ *                scrollPane = new JScrollPane();
+ *                table = new JTable();
+ *                scrollPane.setViewportView(table);
+ *                return scrollPane;
+ *            }
+ *        }; 
+ *        embeddedComposite.populate();
+ * </pre>
+ * <p>
+ * The Swing component is created inside a standard Swing containment hierarchy, rooted in 
+ * a {@link javax.swing.RootPaneContainer}. The root pane container is placed inside an AWT frame, as
+ * returned by {@link org.eclipse.swt.awt.SWT_AWT#new_Frame(Composite)} 
+ * <p>
+ * <b>Note:</b> When you mix components from Swing/AWT and SWT toolkits, there will be two UI event threads,
+ * one for AWT, one for SWT. Most SWT APIs require that you call them from the SWT thread. Swing 
+ * has similar restrictions though it does not enforce them as much as SWT.
+ * <p>
+ * Applications need to be aware of the current thread, and, where necessary, schedule tasks to run 
+ * on another thread. This has always been required in the pure Swing or SWT environments, but when 
+ * mixing Swing and SWT, more of this scheduling will be necessary.
+ * <p>
+ * To schedule work on the AWT event 
+ * thread, you can use:
+ * <ul>
+ * <li>{@link javax.swing.SwingUtilities#invokeLater(Runnable)}
+ * <li>{@link javax.swing.SwingUtilities#invokeAndWait(Runnable)} 
+ * </ul>
+ * <p>
+ * (or similar methods in {@link java.awt.EventQueue})
+ * <p>
+ * To schedule work on the SWT event thread, use:
+ * <ul>
+ * <li>{@link org.eclipse.swt.widgets.Display#asyncExec(Runnable)}
+ * <li>{@link org.eclipse.swt.widgets.Display#syncExec(Runnable)}
+ * </ul>
+ * 
+ * Of course, as in single-toolkit environments, long-running tasks should be offloaded from either UI 
+ * thread to a background thread. The Eclipse jobs API can be used for this purpose.
+ */
+public abstract class EmbeddedSwingComposite extends Composite {
+    private static class AwtContext {
+        private Frame frame;
+        private JComponent swingComponent;
+        
+        AwtContext(Frame frame) {
+            assert frame != null;
+            this.frame = frame;
+        }
+
+        Frame getFrame() {
+            return frame;
+        }
+
+        void setSwingComponent(JComponent swingComponent) {
+            this.swingComponent = swingComponent;
+        }
+
+        JComponent getSwingComponent() {
+            return swingComponent;
+        }
+        
+    }
+    private Font currentSystemFont;
+    private AwtContext awtContext;
+    private AwtFocusHandler awtHandler;
+
+    private Listener settingsListener = new Listener() {
+        public void handleEvent(Event event) {
+            handleSettingsChange();
+        }
+    };
+    
+    // This listener helps ensure that Swing popup menus are properly dismissed when
+    // a menu item off the SWT main menu bar is shown.
+    private final Listener menuListener = new Listener() {
+        public void handleEvent(Event event) {
+            assert awtHandler != null;
+            
+            awtHandler.postHidePopups();
+        }
+    };
+    
+    /**
+     * Constructs a new instance of this class given its parent
+     * and a style value describing its behavior and appearance.
+     * <p>
+     * This method must be called from the SWT event thread. 
+     * <p>
+     * The style value is either one of the style constants defined in
+     * class <code>SWT</code> which is applicable to instances of this
+     * class, or must be built by <em>bitwise OR</em>'ing together 
+     * (that is, using the <code>int</code> "|" operator) two or more
+     * of those <code>SWT</code> style constants. The class description
+     * lists the style constants that are applicable to the class.
+     * Style bits are also inherited from superclasses.
+     * </p>
+     * <p>
+     * The styles SWT.EMBEDDED and SWT.NO_BACKGROUND will be added
+     * to the specified style. Usually, no other style bits are needed.
+     *
+     * @param parent a widget which will be the parent of the new instance (cannot be null)
+     * @param style the style of widget to construct
+     *
+     * @exception IllegalArgumentException <ul>
+     *    <li>ERROR_NULL_ARGUMENT - if the parent is null</li>
+     * </ul>
+     * @exception SWTException <ul>
+     *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the SWT event thread
+     * </ul>
+     *
+     * @see Widget#getStyle
+     */
+    public EmbeddedSwingComposite(Composite parent, int style) {
+        super(parent, style | SWT.EMBEDDED | SWT.NO_BACKGROUND);
+        getDisplay().addListener(SWT.Settings, settingsListener);
+        setLayout(new FillLayout());
+        currentSystemFont = getFont();
+    }
+
+    /**
+     * Populates the embedded composite with the Swing component.
+     * <p> 
+     * This method must be called from the
+     * SWT event thread.  
+     * <p>
+     * The Swing component will be created by calling {@link #createSwingComponent()}. The creation is
+     * scheduled asynchronously on the AWT event thread. This method does not wait for completion of this
+     * asynchronous task, so it may return before createSwingComponent() is complete.   
+     * <p>
+     * The Swing component is created inside a standard Swing containment hierarchy, rooted in 
+     * a {@link javax.swing.RootPaneContainer}. Clients can override {@link #addRootPaneContainer(Frame)}
+     * to provide their own root pane container implementation.
+     * <p>
+     * This method can be called multiple times for a single instance. If an embedded frame exists from 
+     * a previous call, it is disposed.
+     *  
+     * @exception SWTException <ul>
+     *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>
+     *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the SWT event thread
+     * </ul>
+     */
+    public void populate() {
+        checkWidget();
+        createFrame();
+        scheduleComponentCreation();
+    }
+
+    /**
+     * Creates the embedded Swing component. This method is called from the AWT event thread. 
+     * <p> 
+     * Implement this method to provide the Swing component that will be shown inside this composite.
+     * The returned component will be added to the Swing content pane. At least one component must
+     * be created by this method; null is not a valid return value.   
+     *   
+     * @return a non-null Swing component
+     */
+    protected abstract JComponent createSwingComponent();
+    
+    /**
+     * Adds a root pane container to the embedded AWT frame. Override this to provide your own 
+     * {@link javax.swing.RootPaneContainer} implementation. In most cases, it is not necessary
+     * to override this method.    
+     * <p>
+     * This method is called from the AWT event thread. 
+     * <p> 
+     * If you are defining your own root pane container, make sure that there is at least one
+     * heavyweight (AWT) component in the frame's containment hierarchy; otherwise, event 
+     * processing will not work correctly. See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4982522
+     * for more information.  
+     *   
+     * @param frame the frame to which the root pane container is added 
+     * @return a non-null Swing component
+     */
+    protected RootPaneContainer addRootPaneContainer(Frame frame) {
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        assert frame != null;
+        
+        // It is important to set up the proper top level components in the frame:
+        // 1) For Swing to work properly, Sun documents that there must be an implementor of 
+        // javax.swing.RootPaneContainer at the top of the component hierarchy. 
+        // 2) For proper event handling there must be a heavyweight 
+        // an AWT frame must contain a heavyweight component (see 
+        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4982522)
+        // 3) The Swing implementation further narrows the options by expecting that the 
+        // top of the hierarchy be a JFrame, JDialog, JWindow, or JApplet. See javax.swing.PopupFactory.
+        // All this drives the choice of JApplet for the top level Swing component. It is the 
+        // only single component that satisfies all the above. This does not imply that 
+        // we have a true applet; in particular, there is no notion of an applet lifecycle in this
+        // context. 
+        JApplet applet = new JApplet();
+        
+        // In JRE 1.4, the JApplet makes itself a focus cycle root. This
+        // interferes with the focus handling installed on the parent frame, so
+        // change it back to a non-root here. 
+        // TODO: consider moving the focus policy from the Frame down to the JApplet
+        applet.setFocusCycleRoot(false);
+
+        frame.add(applet);
+        
+        return applet;
+    }
+
+    /**
+     * Performs custom updates to newly set fonts. This method is called whenever a change
+     * to the system font through the system settings (i.e. control panel) is detected.
+     * <p>
+     * This method is called from the AWT event thread.  
+     * <p>
+     * In most cases it is not necessary to override this method.  Normally, the implementation
+     * of this class will automatically propogate font changes to the embedded Swing components 
+     * through Swing's Look and Feel support. However, if additional 
+     * special processing is necessary, it can be done inside this method. 
+     *    
+     * @param newFont New AWT font
+     */
+    protected void updateAwtFont(java.awt.Font newFont) {
+    }
+
+    /**
+     * Returns the embedded AWT frame. The returned frame is the root of the AWT containment
+     * hierarchy for the embedded Swing component. This method can be called from 
+     * any thread. 
+     *    
+     * @return the embedded frame
+     */
+    public Frame getFrame() {
+        // Intentionally leaving out checkWidget() call. This may need to be called from within user's 
+        // createSwingComponent() method. Accessing from a non-SWT thread is OK, but we still check
+        // for disposal
+        if (getDisplay() == null || isDisposed()) {
+            SWT.error(SWT.ERROR_WIDGET_DISPOSED);            
+        }
+        
+        return (awtContext != null) ? awtContext.getFrame() : null;
+    }
+
+    private void createFrame() {
+        assert Display.getCurrent() != null;     // On SWT event thread
+        
+        // Make sure Awt environment is initialized. 
+        AwtEnvironment.getInstance(getDisplay());
+        
+        if (awtContext != null) {
+            final Frame oldFrame = awtContext.getFrame();
+            // Schedule disposal of old frame on AWT thread so that there are no problems with
+            // already-scheduled operations that have not completed.
+            // Note: the implementation of Frame.dispose() would schedule the use of the AWT 
+            // thread even if it was not done here, but it uses invokeAndWait() which is 
+            // prone to deadlock (and not necessary for this case). 
+            EventQueue.invokeLater(new Runnable() {
+                public void run() {
+                    oldFrame.dispose();
+                }
+            });
+        }
+        Frame frame = SWT_AWT.new_Frame(this);
+        awtContext = new AwtContext(frame);
+
+        // Glue the two frameworks together. Do this before anything is added to the frame
+        // so that all necessary listeners are in place.
+        createFocusHandlers();
+        
+        // This listener clears garbage during resizing, making it looker much cleaner 
+        addControlListener(new CleanResizeListener());
+    }
+
+    private void createFocusHandlers() {
+        assert awtContext != null;
+        assert Display.getCurrent() != null;     // On SWT event thread
+        
+        Frame frame = awtContext.getFrame();
+        awtHandler = new AwtFocusHandler(frame);   
+        SwtFocusHandler swtHandler = new SwtFocusHandler(this);
+        awtHandler.setSwtHandler(swtHandler);
+        swtHandler.setAwtHandler(awtHandler);
+        
+        // Ensure that AWT popups are dimissed whenever a SWT menu is shown
+        getDisplay().addFilter(SWT.Show, menuListener);
+        
+        EmbeddedChildFocusTraversalPolicy policy = new EmbeddedChildFocusTraversalPolicy(awtHandler);
+        frame.setFocusTraversalPolicy(policy);
+    }
+    
+    private void scheduleComponentCreation() {
+        assert awtContext != null;
+        
+        // Create AWT/Swing components on the AWT thread. This is 
+        // especially necessary to avoid an AWT leak bug (6411042).
+        final AwtContext currentContext = awtContext;
+        EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                
+                RootPaneContainer container = addRootPaneContainer(currentContext.getFrame());
+                JComponent swingComponent = createSwingComponent();
+                currentContext.setSwingComponent(swingComponent);
+                container.getRootPane().getContentPane().add(swingComponent);
+                setComponentFont();
+            }
+        });
+    }
+
+    private void setComponentFont() {
+        assert currentSystemFont != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        JComponent swingComponent = (awtContext != null) ? awtContext.getSwingComponent() : null;
+        if ((swingComponent != null) && !currentSystemFont.getDevice().isDisposed()) {
+            FontData fontData = currentSystemFont.getFontData()[0];
+            
+            // AWT font sizes assume a 72 dpi resolution, always. The true screen resolution must be 
+            // used to convert the platform font size into an AWT point size that matches when displayed. 
+            int resolution = Toolkit.getDefaultToolkit().getScreenResolution();
+            int awtFontSize = (int)Math.round((double)fontData.getHeight() * resolution / 72.0);
+            
+            // The style constants for SWT and AWT map exactly, and since they are int constants, they should
+            // never change. So, the SWT style is passed through as the AWT style. 
+            java.awt.Font awtFont = new java.awt.Font(fontData.getName(), fontData.getStyle(), awtFontSize);
+
+            // Update the look and feel defaults to use new font.
+            updateLookAndFeel(awtFont);
+
+            // Allow subclasses to react to font change if necessary. 
+            updateAwtFont(awtFont);
+
+            // Allow components to update their UI based on new font 
+            // TODO: should the update method be called on the root pane instead?
+            Container contentPane = swingComponent.getRootPane().getContentPane();
+            SwingUtilities.updateComponentTreeUI(contentPane);
+        }
+    }
+    
+    private void updateLookAndFeel(java.awt.Font awtFont) {
+        assert awtFont != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // The FontUIResource class marks the font as replaceable by the look and feel 
+        // implementation if font settings are later changed. 
+        FontUIResource fontResource = new FontUIResource(awtFont);
+
+        // Assign the new font to the relevant L&F font properties. These are 
+        // the properties that are initially assigned to the system font
+        // under the Windows look and feel. 
+        // TODO: It's possible that other platforms will need other assignments.
+        // TODO: This does not handle fonts other than the "system" font. 
+        // Other fonts may change, and the Swing L&F may not be adjusting.
+        
+        UIManager.put("Button.font", fontResource); //$NON-NLS-1$
+        UIManager.put("CheckBox.font", fontResource); //$NON-NLS-1$
+        UIManager.put("ComboBox.font", fontResource); //$NON-NLS-1$
+        UIManager.put("EditorPane.font", fontResource); //$NON-NLS-1$
+        UIManager.put("Label.font", fontResource); //$NON-NLS-1$
+        UIManager.put("List.font", fontResource); //$NON-NLS-1$
+        UIManager.put("Panel.font", fontResource); //$NON-NLS-1$
+        UIManager.put("ProgressBar.font", fontResource); //$NON-NLS-1$
+        UIManager.put("RadioButton.font", fontResource); //$NON-NLS-1$
+        UIManager.put("ScrollPane.font", fontResource); //$NON-NLS-1$
+        UIManager.put("TabbedPane.font", fontResource); //$NON-NLS-1$
+        UIManager.put("Table.font", fontResource); //$NON-NLS-1$
+        UIManager.put("TableHeader.font", fontResource); //$NON-NLS-1$
+        UIManager.put("TextField.font", fontResource); //$NON-NLS-1$
+        UIManager.put("TextPane.font", fontResource); //$NON-NLS-1$
+        UIManager.put("TitledBorder.font", fontResource); //$NON-NLS-1$
+        UIManager.put("ToggleButton.font", fontResource); //$NON-NLS-1$
+        UIManager.put("TreeFont.font", fontResource); //$NON-NLS-1$
+        UIManager.put("ViewportFont.font", fontResource); //$NON-NLS-1$
+    }
+
+    private void handleSettingsChange() {
+        Font newFont = getDisplay().getSystemFont();
+        if (!newFont.equals(currentSystemFont)) { 
+            currentSystemFont = newFont;
+            EventQueue.invokeLater(new Runnable() {
+                public void run() {
+                    setComponentFont();
+                }
+            });            
+        }
+    }
+
+    private boolean isFocusable() {
+        if (awtContext == null) {
+            return false;
+        }
+        JComponent swingComponent = awtContext.getSwingComponent();
+        return (swingComponent != null) && swingComponent.isFocusable(); 
+    }
+
+    /* (non-Javadoc)
+     * @see org.eclipse.swt.widgets.Control#setFocus()
+     */
+    public boolean setFocus() {
+        checkWidget();
+        
+        if (!isFocusable()) {
+            return false;
+        }
+        return super.setFocus();
+    }
+
+    /* (non-Javadoc)
+     * @see org.eclipse.swt.widgets.Control#forceFocus()
+     */
+    public boolean forceFocus() {
+        checkWidget();
+        
+        if (!isFocusable()) {
+            return false;
+        }
+        return super.forceFocus();
+    }
+
+    /* (non-Javadoc)
+     * @see org.eclipse.swt.widgets.Widget#dispose()
+     */
+    public void dispose() {
+        if (!isDisposed()) {
+            getDisplay().removeListener(SWT.Settings, settingsListener);
+            getDisplay().removeFilter(SWT.Show, menuListener);
+            super.dispose();
+        }
+    }
+    
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/awt/EmbeddedSwingComposite.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/awt/Platform.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/awt/Platform.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/gui/swt/awt/Platform.java	(revision 1041)
@@ -14,33 +14,33 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-/*******************************************************************************
- * Copyright (c) 2007 SAS Institute.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     SAS Institute - initial API and implementation
- *******************************************************************************/
-package org.pathvisio.gui.swt.awt;
-
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
 import org.eclipse.swt.SWT;
-
-class Platform {
-    private static String platformString = SWT.getPlatform();
-
-    // prevent instantiation
-    private Platform() {
-    }
-    
-    public static boolean isWin32() {
-        return "win32".equals(platformString); //$NON-NLS-1$
-    }
-    
-    public static boolean isGtk() {
-        return "gtk".equals(platformString); //$NON-NLS-1$
-    }
-    
-}
+
+class Platform {
+    private static String platformString = SWT.getPlatform();
+
+    // prevent instantiation
+    private Platform() {
+    }
+    
+    public static boolean isWin32() {
+        return "win32".equals(platformString); //$NON-NLS-1$
+    }
+    
+    public static boolean isGtk() {
+        return "gtk".equals(platformString); //$NON-NLS-1$
+    }
+    
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/awt/Platform.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/awt/AwtFocusHandler.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/awt/AwtFocusHandler.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/gui/swt/awt/AwtFocusHandler.java	(revision 1041)
@@ -14,18 +14,18 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-/*******************************************************************************
- * Copyright (c) 2007 SAS Institute.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     SAS Institute - initial API and implementation
- *******************************************************************************/
-package org.pathvisio.gui.swt.awt;
-
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
 import java.awt.Component;
 import java.awt.Container;
 import java.awt.EventQueue;
@@ -45,226 +45,226 @@
 import javax.swing.JPopupMenu;
 import javax.swing.text.Caret;
 import javax.swing.text.JTextComponent;
-
-class AwtFocusHandler implements FocusListener, ContainerListener, 
-                                      WindowFocusListener {
-
-    private final Frame frame;
-    private SwtFocusHandler swtHandler;
-    private boolean awtHasFocus = false;
-    private Component currentComponent = null;
-    
-    AwtFocusHandler(Frame frame) {
-        assert frame != null;
-        
-        this.frame = frame;
-        frame.addContainerListener(new RecursiveContainerListener(this));
-        frame.addWindowFocusListener(this);
-    }
-
-    void setSwtHandler(SwtFocusHandler handler) {
-        assert handler != null;
-        assert swtHandler == null;  // this method is meant to be called once
-        
-        swtHandler = handler;
-    }
-
-    void gainFocus() {
-        assert frame != null;
-        // assert !awtHasFocus;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        FocusTraversalPolicy policy = frame.getFocusTraversalPolicy();
-        Component component;
-        if (policy instanceof EmbeddedChildFocusTraversalPolicy) {
-            EmbeddedChildFocusTraversalPolicy embeddedPolicy = (EmbeddedChildFocusTraversalPolicy) policy; 
-            component = embeddedPolicy.getCurrentComponent(frame);
-        } else {
-            // TODO: direction based?
-            component = policy.getDefaultComponent(frame);
-        }
-        if (component != null) {
-            // System.out.println("Requesting focus for component: " + component);
-            component.requestFocus();
-            // TODO: else case error? If not, consider moving flag setting below into this if
-        }
-        awtHasFocus = true;
-    }
-    
-    /**
-     * Moves focus back to the next SWT component
-     */
-    void transferFocusNext() {
-        assert swtHandler != null;
-        assert awtHasFocus;
-        
-        awtHasFocus = false;
-        swtHandler.gainFocusNext();
-    }
-    
-    /**
-     * Moves focus back to the previous SWT component
-     */
-    void transferFocusPrevious() {
-        assert swtHandler != null;
-        assert awtHasFocus;
-        
-        awtHasFocus = false;
-        swtHandler.gainFocusPrevious();
-    }
-    
-    boolean awtHasFocus() {
-        return awtHasFocus;
-    }
-
-    Component getCurrentComponent() {
-        return currentComponent;
-    }
-    
-    // ..................... Listener implementations
-
-    public void focusGained(FocusEvent e) {
-        assert e != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        // System.out.println("gained (awt). component = " + e.getComponent() + ", opposite = " + e.getOppositeComponent());
-        currentComponent  = e.getComponent();
-    }
-
-    public void focusLost(FocusEvent e) {
-        // System.out.println("component focus lost (awt). opposite = " + e.getOppositeComponent());
-        
-        // Intentionally leaving currentComponent set. When window focus is lost, 
-        // it will be needed. 
-    }
-
-    public void componentAdded(ContainerEvent e) {
-        assert e != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        e.getChild().addFocusListener(this);
-    }
-
-    public void componentRemoved(ContainerEvent e) {
-        assert e != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        e.getChild().removeFocusListener(this);
-    }
-    
-    public void windowGainedFocus(WindowEvent e) {
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        // System.out.println("WindowFocusListener.windowGainedFocus");
-        awtHasFocus = true;
-    }
-
-    public void windowLostFocus(WindowEvent e) {
-        assert e != null;
-        assert swtHandler != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        // System.out.println("WindowFocusListener.windowLostFocus");
-        
-        // Dismiss any popup menus that are
-        // open when losing focus. This prevents situations where
-        // multiple popup menus are visible at the same time. In JDK 1.4 and earlier, 
-        // the dismissal is not done automatically. In JDK 1.5, this code is 
-        // unnecessary, but it doesn't seem to hurt anything. 
-        // TODO: verify this is OK on other windowing systems
-        // TODO: disable in post-1.4 environments
-        /* boolean popupShown = */hidePopups();
-        
-        // If focus is being lost to the parent SWT composite, then
-        // grab it back for AWT and return. Normally the parent SWT composite will
-        // do this for us, but it will not see a focus gained event when focus 
-        // is transferred to it from its AWT frame child. 
-        // This happens, for example, if an AWT control has focus and the 
-        // tab of a containing (already active) view is clicked.
-        //
-        // However, don't grab back focus if a popup was hidden above. The popup
-        // area will not be properly redrawn (the popup, or part of it, will 
-        // appear to be still there. 
-        //if (!popupShown && swtHandler.hasFocus()) {
-            // System.out.println("**** Taking back focus: " + e);
-            // This seems to have side effects, so it's commented out for now. 
-            // (Sometimes, it forces the workbench window to the foreground when another
-            // program's window is selected.)
-            // TODO: find an alternate approach to reassert focus
-            // gainFocus();
-            // return;
-        //}
-        
-        // On a normal change of focus, Swing will turn off any selection
-        // in a text field to help indicate focus is lost. This won't happen
-        // automatically when transferring to SWT, so turn off the selection
-        // manually.
-        if (currentComponent instanceof JTextComponent) {
-            Caret caret = ((JTextComponent)currentComponent).getCaret();
-            if (caret != null) {
-                caret.setSelectionVisible(false);
-            }
-        }
-        awtHasFocus = false;
-    }
-
-    // Returns true if any popup has been hidden
-    private boolean hidePopups() {
-        boolean result = false;
-        List popups = new ArrayList();
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        // Look for popups inside the frame's component hierarchy. 
-        // Lightweight popups will be found here. 
-        findContainedPopups(frame, popups);
-        
-        // Also look for popups in the frame's window hierachy. 
-        // Heavyweight popups will be found here.
-        findOwnedPopups(frame, popups);
-        
-        // System.out.println("Hiding popups, count=" + popups.size());
-        for (Iterator iter = popups.iterator(); iter.hasNext();) {
-            Component popup = (Component)iter.next();
-            if (popup.isVisible()) {
-                result = true;
-                popup.setVisible(false);
-            }
-        }
-        return result;
-    }
-
-    private void findOwnedPopups(Window window, List popups) {
-        assert window != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        Window[] ownedWindows = window.getOwnedWindows();
-        for (int i = 0; i < ownedWindows.length; i++) {
-            findContainedPopups(ownedWindows[i], popups);
-            findOwnedPopups(ownedWindows[i], popups);
-        }
-    }
-
-    private void findContainedPopups(Container container, List popups) {
-        assert container != null;
-        assert popups != null;
-        assert EventQueue.isDispatchThread();    // On AWT event thread
-        
-        Component[] components = container.getComponents();
-        for (int i = 0; i < components.length; i++) {
-            Component c = components[i];
-            // JPopupMenu is a container, so check for it first
-            if (c instanceof JPopupMenu) {
-                popups.add(c);
-            } else if (c instanceof Container) {
-                findContainedPopups((Container)c, popups);
-            }
-        }
-    }
-
-    void postHidePopups() {
-        EventQueue.invokeLater(new Runnable() {
-            public void run() {
-                hidePopups();
-            }
-        });
-    }
-}
+
+class AwtFocusHandler implements FocusListener, ContainerListener, 
+                                      WindowFocusListener {
+
+    private final Frame frame;
+    private SwtFocusHandler swtHandler;
+    private boolean awtHasFocus = false;
+    private Component currentComponent = null;
+    
+    AwtFocusHandler(Frame frame) {
+        assert frame != null;
+        
+        this.frame = frame;
+        frame.addContainerListener(new RecursiveContainerListener(this));
+        frame.addWindowFocusListener(this);
+    }
+
+    void setSwtHandler(SwtFocusHandler handler) {
+        assert handler != null;
+        assert swtHandler == null;  // this method is meant to be called once
+        
+        swtHandler = handler;
+    }
+
+    void gainFocus() {
+        assert frame != null;
+        // assert !awtHasFocus;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        FocusTraversalPolicy policy = frame.getFocusTraversalPolicy();
+        Component component;
+        if (policy instanceof EmbeddedChildFocusTraversalPolicy) {
+            EmbeddedChildFocusTraversalPolicy embeddedPolicy = (EmbeddedChildFocusTraversalPolicy) policy; 
+            component = embeddedPolicy.getCurrentComponent(frame);
+        } else {
+            // TODO: direction based?
+            component = policy.getDefaultComponent(frame);
+        }
+        if (component != null) {
+            // System.out.println("Requesting focus for component: " + component);
+            component.requestFocus();
+            // TODO: else case error? If not, consider moving flag setting below into this if
+        }
+        awtHasFocus = true;
+    }
+    
+    /**
+     * Moves focus back to the next SWT component
+     */
+    void transferFocusNext() {
+        assert swtHandler != null;
+        assert awtHasFocus;
+        
+        awtHasFocus = false;
+        swtHandler.gainFocusNext();
+    }
+    
+    /**
+     * Moves focus back to the previous SWT component
+     */
+    void transferFocusPrevious() {
+        assert swtHandler != null;
+        assert awtHasFocus;
+        
+        awtHasFocus = false;
+        swtHandler.gainFocusPrevious();
+    }
+    
+    boolean awtHasFocus() {
+        return awtHasFocus;
+    }
+
+    Component getCurrentComponent() {
+        return currentComponent;
+    }
+    
+    // ..................... Listener implementations
+
+    public void focusGained(FocusEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("gained (awt). component = " + e.getComponent() + ", opposite = " + e.getOppositeComponent());
+        currentComponent  = e.getComponent();
+    }
+
+    public void focusLost(FocusEvent e) {
+        // System.out.println("component focus lost (awt). opposite = " + e.getOppositeComponent());
+        
+        // Intentionally leaving currentComponent set. When window focus is lost, 
+        // it will be needed. 
+    }
+
+    public void componentAdded(ContainerEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        e.getChild().addFocusListener(this);
+    }
+
+    public void componentRemoved(ContainerEvent e) {
+        assert e != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        e.getChild().removeFocusListener(this);
+    }
+    
+    public void windowGainedFocus(WindowEvent e) {
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        // System.out.println("WindowFocusListener.windowGainedFocus");
+        awtHasFocus = true;
+    }
+
+    public void windowLostFocus(WindowEvent e) {
+        assert e != null;
+        assert swtHandler != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // System.out.println("WindowFocusListener.windowLostFocus");
+        
+        // Dismiss any popup menus that are
+        // open when losing focus. This prevents situations where
+        // multiple popup menus are visible at the same time. In JDK 1.4 and earlier, 
+        // the dismissal is not done automatically. In JDK 1.5, this code is 
+        // unnecessary, but it doesn't seem to hurt anything. 
+        // TODO: verify this is OK on other windowing systems
+        // TODO: disable in post-1.4 environments
+        /* boolean popupShown = */hidePopups();
+        
+        // If focus is being lost to the parent SWT composite, then
+        // grab it back for AWT and return. Normally the parent SWT composite will
+        // do this for us, but it will not see a focus gained event when focus 
+        // is transferred to it from its AWT frame child. 
+        // This happens, for example, if an AWT control has focus and the 
+        // tab of a containing (already active) view is clicked.
+        //
+        // However, don't grab back focus if a popup was hidden above. The popup
+        // area will not be properly redrawn (the popup, or part of it, will 
+        // appear to be still there. 
+        //if (!popupShown && swtHandler.hasFocus()) {
+            // System.out.println("**** Taking back focus: " + e);
+            // This seems to have side effects, so it's commented out for now. 
+            // (Sometimes, it forces the workbench window to the foreground when another
+            // program's window is selected.)
+            // TODO: find an alternate approach to reassert focus
+            // gainFocus();
+            // return;
+        //}
+        
+        // On a normal change of focus, Swing will turn off any selection
+        // in a text field to help indicate focus is lost. This won't happen
+        // automatically when transferring to SWT, so turn off the selection
+        // manually.
+        if (currentComponent instanceof JTextComponent) {
+            Caret caret = ((JTextComponent)currentComponent).getCaret();
+            if (caret != null) {
+                caret.setSelectionVisible(false);
+            }
+        }
+        awtHasFocus = false;
+    }
+
+    // Returns true if any popup has been hidden
+    private boolean hidePopups() {
+        boolean result = false;
+        List popups = new ArrayList();
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        // Look for popups inside the frame's component hierarchy. 
+        // Lightweight popups will be found here. 
+        findContainedPopups(frame, popups);
+        
+        // Also look for popups in the frame's window hierachy. 
+        // Heavyweight popups will be found here.
+        findOwnedPopups(frame, popups);
+        
+        // System.out.println("Hiding popups, count=" + popups.size());
+        for (Iterator iter = popups.iterator(); iter.hasNext();) {
+            Component popup = (Component)iter.next();
+            if (popup.isVisible()) {
+                result = true;
+                popup.setVisible(false);
+            }
+        }
+        return result;
+    }
+
+    private void findOwnedPopups(Window window, List popups) {
+        assert window != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        Window[] ownedWindows = window.getOwnedWindows();
+        for (int i = 0; i < ownedWindows.length; i++) {
+            findContainedPopups(ownedWindows[i], popups);
+            findOwnedPopups(ownedWindows[i], popups);
+        }
+    }
+
+    private void findContainedPopups(Container container, List popups) {
+        assert container != null;
+        assert popups != null;
+        assert EventQueue.isDispatchThread();    // On AWT event thread
+        
+        Component[] components = container.getComponents();
+        for (int i = 0; i < components.length; i++) {
+            Component c = components[i];
+            // JPopupMenu is a container, so check for it first
+            if (c instanceof JPopupMenu) {
+                popups.add(c);
+            } else if (c instanceof Container) {
+                findContainedPopups((Container)c, popups);
+            }
+        }
+    }
+
+    void postHidePopups() {
+        EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                hidePopups();
+            }
+        });
+    }
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/awt/AwtFocusHandler.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/awt/CleanResizeListener.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/awt/CleanResizeListener.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/gui/swt/awt/CleanResizeListener.java	(revision 1041)
@@ -14,50 +14,50 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-/*******************************************************************************
- * Copyright (c) 2007 SAS Institute.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     SAS Institute - initial API and implementation
- *******************************************************************************/
-package org.pathvisio.gui.swt.awt;
-
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
 import org.eclipse.swt.events.ControlAdapter;
 import org.eclipse.swt.events.ControlEvent;
 import org.eclipse.swt.graphics.GC;
 import org.eclipse.swt.graphics.Rectangle;
 import org.eclipse.swt.widgets.Composite;
 import org.eclipse.swt.widgets.Display;
-
-class CleanResizeListener extends ControlAdapter {
-    private Rectangle oldRect = null;
-    public void controlResized(ControlEvent e) {
-        assert e != null;
-        assert Display.getCurrent() != null;     // On SWT event thread
-        
-        // Prevent garbage from Swing lags during resize. Fill exposed areas 
-        // with background color. 
-        Composite composite = (Composite)e.widget;
-        //Rectangle newRect = composite.getBounds();
-        //newRect = composite.getDisplay().map(composite.getParent(), composite, newRect);
-        Rectangle newRect = composite.getClientArea();
-        if (oldRect != null) {
-            int heightDelta = newRect.height - oldRect.height;
-            int widthDelta = newRect.width - oldRect.width;
-            if ((heightDelta > 0) || (widthDelta > 0)) {
-                GC gc = new GC(composite);
-                try {
-                    gc.fillRectangle(newRect.x, oldRect.height, newRect.width, heightDelta);
-                    gc.fillRectangle(oldRect.width, newRect.y, widthDelta, newRect.height);
-                } finally {
-                    gc.dispose();
-                }
-            }
-        }
-        oldRect = newRect;
-    }
+
+class CleanResizeListener extends ControlAdapter {
+    private Rectangle oldRect = null;
+    public void controlResized(ControlEvent e) {
+        assert e != null;
+        assert Display.getCurrent() != null;     // On SWT event thread
+        
+        // Prevent garbage from Swing lags during resize. Fill exposed areas 
+        // with background color. 
+        Composite composite = (Composite)e.widget;
+        //Rectangle newRect = composite.getBounds();
+        //newRect = composite.getDisplay().map(composite.getParent(), composite, newRect);
+        Rectangle newRect = composite.getClientArea();
+        if (oldRect != null) {
+            int heightDelta = newRect.height - oldRect.height;
+            int widthDelta = newRect.width - oldRect.width;
+            if ((heightDelta > 0) || (widthDelta > 0)) {
+                GC gc = new GC(composite);
+                try {
+                    gc.fillRectangle(newRect.x, oldRect.height, newRect.width, heightDelta);
+                    gc.fillRectangle(oldRect.width, newRect.y, widthDelta, newRect.height);
+                } finally {
+                    gc.dispose();
+                }
+            }
+        }
+        oldRect = newRect;
+    }
 }
\ No newline at end of file

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/awt/CleanResizeListener.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/gui/swt/awt/SwtFocusHandler.java
===================================================================
--- trunk/src/swt/org/pathvisio/gui/swt/awt/SwtFocusHandler.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/gui/swt/awt/SwtFocusHandler.java	(revision 1041)
@@ -14,18 +14,18 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-/*******************************************************************************
- * Copyright (c) 2007 SAS Institute.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     SAS Institute - initial API and implementation
- *******************************************************************************/
-package org.pathvisio.gui.swt.awt;
-
+/*******************************************************************************
+ * Copyright (c) 2007 SAS Institute.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *     SAS Institute - initial API and implementation
+ *******************************************************************************/
+package org.pathvisio.gui.swt.awt;
+
 import java.awt.EventQueue;
 
 import org.eclipse.swt.SWT;
@@ -40,130 +40,130 @@
 import org.eclipse.swt.widgets.Composite;
 import org.eclipse.swt.widgets.Display;
 import org.eclipse.swt.widgets.Shell;
-
-class SwtFocusHandler implements FocusListener, KeyListener {
-
-    private final Composite composite;
-    private final Display display;
-    private AwtFocusHandler awtHandler;
-    
-    SwtFocusHandler(Composite composite) {
-        assert composite != null;
-        assert Display.getCurrent() != null;     // On SWT event thread
-        
-        this.composite = composite;
-        display = composite.getDisplay();
-        composite.addFocusListener(this);
-        composite.addKeyListener(this);
-    }
-
-    void setAwtHandler(AwtFocusHandler handler) {
-        assert handler != null;
-        assert awtHandler == null;  // this method is meant to be called once
-        assert composite != null;
-        assert Display.getCurrent() != null;     // On SWT event thread        
-        
-        awtHandler = handler;
-        
-        // Dismiss Swing popups when the main window is moved. (It would be 
-        // better to dismiss popups whenever the titlebar is clicked, but 
-        // there does not seem to be a way.)
-        final ControlAdapter controlAdapter = new ControlAdapter() {
-            public void controlMoved(ControlEvent e) {
-                assert awtHandler != null;
-                awtHandler.postHidePopups();
-            }
-        };
-        final Shell shell = composite.getShell();
-        shell.addControlListener(controlAdapter);
-        
-        // Cleanup listeners on dispose
-        composite.addDisposeListener(new DisposeListener() {
-            public void widgetDisposed(DisposeEvent e) {
-                shell.removeControlListener(controlAdapter);
-            }
-        });
-    }
-    
-    void gainFocusNext() {
-        traverse(SWT.TRAVERSE_TAB_NEXT);
-    }
-    
-    void gainFocusPrevious() {
-        traverse(SWT.TRAVERSE_TAB_PREVIOUS);
-    }
-    
-    private void traverse(final int traversal) {
-        assert composite != null;
-        
-        // Tab from the containing SWT component while 
-        // running on the SWT thread
-        Runnable r = new Runnable() {
-            public void run() {
-                composite.traverse(traversal);
-            }
-        };
-        display.asyncExec(r);
-    }
-
-//    boolean hasFocus() {
-//        assert composite != null;
-//        
-//        // This will return true if the composite has focus, or if any
-//        // foreign (e.g. AWT) child of the composite has focus.
-//        if (display.isDisposed()) {
-//            return false;
-//        }
-//        final boolean[] result = new boolean[1];
-//        display.syncExec(new Runnable() {
-//            public void run() {
-//                result[0] = (!composite.isDisposed() &&
-//                             (display.getFocusControl() == composite));
-//            }
-//        });
-//        return result[0];
-//    }
-
-    // ..................... Listener implementations
-    
-    public void focusGained(FocusEvent e) {
-        assert awtHandler != null;
-        assert Display.getCurrent() != null;     // On SWT event thread
-        
-        // System.out.println("Gained: " + e.toString() + " (" + e.widget.getClass().getName() + ")");
-        EventQueue.invokeLater(new Runnable() {
-            public void run() {
-                awtHandler.gainFocus();
-            }
-        });        
-    }
-    
-    public void focusLost(FocusEvent e) {
-        // System.out.println("Lost: " + e.toString() + " (" + e.widget.getClass().getName() + ")");
-    }
-
-    public void keyPressed(KeyEvent e) {
-        assert Display.getCurrent() != null;     // On SWT event thread
-
-        // If the embedded swing root pane has no components to receive focus, 
-        // then there will be cases where the parent SWT composite will keep 
-        // focus. (For example, when tabbing into the root pane container). 
-        // By default, in these cases, the focus is swallowed by the Composite
-        // and never escapes. This code allows tab and back-tab to do the 
-        // proper traversal to other SWT components from the composite.
-        // TODO: other keys?
-        if (e.keyCode == SWT.TAB) {
-            // TODO: In some cases, this gobbles up all the tabs, even from AWT children. Find a more selective way. 
-            /*if (e.stateMask == SWT.NONE) {
-                traverse(SWT.TRAVERSE_TAB_NEXT);
-            } else if (e.stateMask == SWT.SHIFT) {
-                traverse(SWT.TRAVERSE_TAB_PREVIOUS);
-            }*/
-        }
-    }
-
-    public void keyReleased(KeyEvent e) {
-    }
-
-
-}
+
+class SwtFocusHandler implements FocusListener, KeyListener {
+
+    private final Composite composite;
+    private final Display display;
+    private AwtFocusHandler awtHandler;
+    
+    SwtFocusHandler(Composite composite) {
+        assert composite != null;
+        assert Display.getCurrent() != null;     // On SWT event thread
+        
+        this.composite = composite;
+        display = composite.getDisplay();
+        composite.addFocusListener(this);
+        composite.addKeyListener(this);
+    }
+
+    void setAwtHandler(AwtFocusHandler handler) {
+        assert handler != null;
+        assert awtHandler == null;  // this method is meant to be called once
+        assert composite != null;
+        assert Display.getCurrent() != null;     // On SWT event thread        
+        
+        awtHandler = handler;
+        
+        // Dismiss Swing popups when the main window is moved. (It would be 
+        // better to dismiss popups whenever the titlebar is clicked, but 
+        // there does not seem to be a way.)
+        final ControlAdapter controlAdapter = new ControlAdapter() {
+            public void controlMoved(ControlEvent e) {
+                assert awtHandler != null;
+                awtHandler.postHidePopups();
+            }
+        };
+        final Shell shell = composite.getShell();
+        shell.addControlListener(controlAdapter);
+        
+        // Cleanup listeners on dispose
+        composite.addDisposeListener(new DisposeListener() {
+            public void widgetDisposed(DisposeEvent e) {
+                shell.removeControlListener(controlAdapter);
+            }
+        });
+    }
+    
+    void gainFocusNext() {
+        traverse(SWT.TRAVERSE_TAB_NEXT);
+    }
+    
+    void gainFocusPrevious() {
+        traverse(SWT.TRAVERSE_TAB_PREVIOUS);
+    }
+    
+    private void traverse(final int traversal) {
+        assert composite != null;
+        
+        // Tab from the containing SWT component while 
+        // running on the SWT thread
+        Runnable r = new Runnable() {
+            public void run() {
+                composite.traverse(traversal);
+            }
+        };
+        display.asyncExec(r);
+    }
+
+//    boolean hasFocus() {
+//        assert composite != null;
+//        
+//        // This will return true if the composite has focus, or if any
+//        // foreign (e.g. AWT) child of the composite has focus.
+//        if (display.isDisposed()) {
+//            return false;
+//        }
+//        final boolean[] result = new boolean[1];
+//        display.syncExec(new Runnable() {
+//            public void run() {
+//                result[0] = (!composite.isDisposed() &&
+//                             (display.getFocusControl() == composite));
+//            }
+//        });
+//        return result[0];
+//    }
+
+    // ..................... Listener implementations
+    
+    public void focusGained(FocusEvent e) {
+        assert awtHandler != null;
+        assert Display.getCurrent() != null;     // On SWT event thread
+        
+        // System.out.println("Gained: " + e.toString() + " (" + e.widget.getClass().getName() + ")");
+        EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                awtHandler.gainFocus();
+            }
+        });        
+    }
+    
+    public void focusLost(FocusEvent e) {
+        // System.out.println("Lost: " + e.toString() + " (" + e.widget.getClass().getName() + ")");
+    }
+
+    public void keyPressed(KeyEvent e) {
+        assert Display.getCurrent() != null;     // On SWT event thread
+
+        // If the embedded swing root pane has no components to receive focus, 
+        // then there will be cases where the parent SWT composite will keep 
+        // focus. (For example, when tabbing into the root pane container). 
+        // By default, in these cases, the focus is swallowed by the Composite
+        // and never escapes. This code allows tab and back-tab to do the 
+        // proper traversal to other SWT components from the composite.
+        // TODO: other keys?
+        if (e.keyCode == SWT.TAB) {
+            // TODO: In some cases, this gobbles up all the tabs, even from AWT children. Find a more selective way. 
+            /*if (e.stateMask == SWT.NONE) {
+                traverse(SWT.TRAVERSE_TAB_NEXT);
+            } else if (e.stateMask == SWT.SHIFT) {
+                traverse(SWT.TRAVERSE_TAB_PREVIOUS);
+            }*/
+        }
+    }
+
+    public void keyReleased(KeyEvent e) {
+    }
+
+
+}

Property changes on: trunk/src/swt/org/pathvisio/gui/swt/awt/SwtFocusHandler.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/data/CachedData.java
===================================================================
--- trunk/src/swt/org/pathvisio/data/CachedData.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/data/CachedData.java	(revision 1041)
@@ -14,8 +14,8 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-package org.pathvisio.data;
-
+package org.pathvisio.data;
+
 import java.sql.Types;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -23,206 +23,206 @@
 
 import org.pathvisio.data.Gdb.IdCodePair;
 import org.pathvisio.data.Gex.Sample;
-
-/**
- * This class represents cached expression data for a pathway.
- * The caching of expression data will occur when a pathway is opened and an expression dataset is loaded.
- * The cache will be refreshed when another dataset is selected, another gene database is selected or another
- * pathway is opened.
- * A CachedData object will contain a list of {@link Data} object for every gene-product on the pathway for 
- * which data is available in the expression dataset
- * @author Thomas
- * @see Gex#cacheData
- */
-public class CachedData {
-	
-	HashMap<IdCodePair, List<Data>> data; //Data objects for gene-products on the pathway
-		
-	protected CachedData() {
-		data = new HashMap<IdCodePair, List<Data>>();
-	}
-	
-	/**
-	 * Check whether the cached data contains data for the given gene-product
-	 * @param pwId The IdCodePair that represents the gene-product
-	 * @return true if data is available for the gene-product, false if not
-	 */
-	public boolean hasData(IdCodePair pwId) {
-		return data.containsKey(pwId);
-	}
-	
-	/**
-	 * Check whether the cached data contains multiple data instances for the given gene-product.
-	 * This can occur when multiple reporters in the dataset correspond to the same gene-product.
-	 * @param pwId The IdCodePair that represents the gene-product
-	 * @return true if multiple data is available for the gene-product, false if not
-	 */
-	public boolean hasMultipleData(IdCodePair pwId) {
-		List<Data> d = data.get(pwId);
-		if(d != null) {
-			return d.size() > 1;
-		} else {
-			return false;
-		}
-	}
-	
-	/**
-	 * Get the cached data the given gene-product
-	 * @param idc The IdCodePair that represents the gene-product for which the data has to be returned
-	 * @return a list of {@link Data} object containing the cached data, or null when no data is available
-	 */
-	public List<Data> getData(IdCodePair idc) {
-		return data.get(idc);
-	}
-	
-	/**
-	 * Get the first {@link Data} instance of the cached data for this gene-product.
-	 * @param idc The IdCodePair that represents the gene-product for which the data has to be returned
-	 * @return a {@link Data} instance that contains the cached data
-	 */
-	public Data getSingleData(IdCodePair idc) {
-		List<Data> dlist = data.get(idc);
-		if(dlist != null && dlist.size() > 0) return dlist.get(0);
-		return null;
-	}
-	
-	/**
-	 * Add cached data for the given gene-product
-	 * @param idc The IdCodePair that represents the gene-product for which the data has to be added
-	 * @param d The data that has to be added
-	 */
-	protected void addData(IdCodePair idc, Data d) {
-		List<Data> dlist = data.get(idc);
-		if(dlist == null) 
-			data.put(idc, dlist = new ArrayList<Data>());
-		dlist.add(d);
-	}
-	
-	/**
-	 * Get the averaged sample data for the given gene-product
-	 * @param idc The IdCodePair that represents the gene-product to get the data for
-	 * @return a HashMap where the keys represent the sample ids and the values the averaged data
-	 * @see Data#getSampleData()
-	 */
-	public HashMap<Integer, Object> getAverageSampleData(IdCodePair idc)
-	{
-		HashMap<Integer, Object> averageData = new HashMap<Integer, Object>();
-		List<Data> dlist = data.get(idc);
-		if(dlist != null) {
-			HashMap<Integer, Sample> samples = Gex.getSamples();
-			for(int idSample : samples.keySet())
-			{
-				int dataType = samples.get(idSample).getDataType();
-				if(dataType == Types.REAL) {
-					averageData.put(idSample, averageDouble(dlist, idSample));
-				} else {
-					averageData.put(idSample, averageString(dlist, idSample));
-				}
-			}
-		}
-		return averageData;
-	}
-	
-	
-	private Object averageDouble(List<Data> dlist, int idSample)
-	{
-		double avg = 0;
-		int n = 0;
-		for(Data d : dlist) {
-			try { 
-				Double value = (Double)d.getSampleData(idSample);
-				if( !value.isNaN() ) {
-					avg += value;
-					n++;
-				}
-			} catch(Exception e) { }
-		}
-		if(n > 0) {
-			return avg / n;
-		} else {
-			return Double.NaN;
-		}
-	}
-	
-	private Object averageString(List<Data> dlist, int idSample)
-	{
-		StringBuilder sb = new StringBuilder();
-		for(Data d : dlist) {
-			sb.append(d.getSampleData(idSample) + ", ");
-		}
-		int end = sb.lastIndexOf(", ");
-		return end < 0 ? "" : sb.substring(0, end).toString();
-	}
-	
-	/**
-	 * This class represents cached expression data for a reporter in the dataset.
-	 * The data is stored in a {@link HashMap} where the keys are the sample ids and the value
-	 * is an object of class {@link String} or {@link Double} for text and numeric data respectively.
-	 * @author Thomas
-	 */
-	public static class Data {
-		IdCodePair idc;
-		int group;
-		HashMap<Integer, Object> sampleData;
-		
-		/**
-		 * Constructor for this class. Creates a new {@link Data} object for the given reporter
-		 * @param ref The IdCodePair that represents the reporter
-		 * @param groupId An id that groups the expression data from duplicate reporters
-		 */
-		protected Data(IdCodePair ref, int groupId) {
-			idc = ref;
-			group = groupId;
-			sampleData = new HashMap<Integer, Object>();
-		}
-		
-		/**
-		 * Get the reporter this object contains data for
-		 * @return The IdCodePair that represents the reporter this object contains data for
-		 */
-		public IdCodePair getIdCodePair() { return idc; }
-		
-		/**
-		 * Get the group id for this object
-		 * @return a group id that can be used to distinct identical reporters that occur more
-		 * than once in the dataset
-		 */
-		public int getGroup() { return group; }
-		
-		/**
-		 * Get the data for each sample
-		 * @return A {@link HashMap} that contains the data for each sample. The key is a sampleId and value
-		 * is an object of class {@link String} or {@link Double}, depending on the data type of the sample.
-		 * @see Sample#getDataType()
-		 * @see Sample#getId()
-		 */
-		public HashMap<Integer, Object> getSampleData() {
-			return sampleData;
-		}
-		
-		/**
-		 * Get the cached data for the given sample (shortcut for getSampleData().get(sampleId))
-		 * @param sampleId The id of the sample to get the data for
-		 * @return An object of class {@link String} or {@link Double}, depending on the datatype of the sample.
-		 * @see Sample#getDataType()
-		 * @see Sample#getId()
-		 */
-		public Object getSampleData(int sampleId) {
-			return sampleData.get(sampleId);
-		}
-		
-		/**
-		 * Set the data for the given sample. Data will be parsed to double if possible
-		 * @param sampleId The id of the sample to set the data for
-		 * @param data The {@link String} representation of the data to add
-		 * @see Gex#cacheData
-		 */
-		protected void setSampleData(int sampleId, String data) {
-			Object parsedData = null;
-			try { parsedData = Double.parseDouble(data); }
-			catch(Exception e) { parsedData = data; }
-			sampleData.put(sampleId, parsedData);
-		}
-		
-	}
-}
+
+/**
+ * This class represents cached expression data for a pathway.
+ * The caching of expression data will occur when a pathway is opened and an expression dataset is loaded.
+ * The cache will be refreshed when another dataset is selected, another gene database is selected or another
+ * pathway is opened.
+ * A CachedData object will contain a list of {@link Data} object for every gene-product on the pathway for 
+ * which data is available in the expression dataset
+ * @author Thomas
+ * @see Gex#cacheData
+ */
+public class CachedData {
+	
+	HashMap<IdCodePair, List<Data>> data; //Data objects for gene-products on the pathway
+		
+	protected CachedData() {
+		data = new HashMap<IdCodePair, List<Data>>();
+	}
+	
+	/**
+	 * Check whether the cached data contains data for the given gene-product
+	 * @param pwId The IdCodePair that represents the gene-product
+	 * @return true if data is available for the gene-product, false if not
+	 */
+	public boolean hasData(IdCodePair pwId) {
+		return data.containsKey(pwId);
+	}
+	
+	/**
+	 * Check whether the cached data contains multiple data instances for the given gene-product.
+	 * This can occur when multiple reporters in the dataset correspond to the same gene-product.
+	 * @param pwId The IdCodePair that represents the gene-product
+	 * @return true if multiple data is available for the gene-product, false if not
+	 */
+	public boolean hasMultipleData(IdCodePair pwId) {
+		List<Data> d = data.get(pwId);
+		if(d != null) {
+			return d.size() > 1;
+		} else {
+			return false;
+		}
+	}
+	
+	/**
+	 * Get the cached data the given gene-product
+	 * @param idc The IdCodePair that represents the gene-product for which the data has to be returned
+	 * @return a list of {@link Data} object containing the cached data, or null when no data is available
+	 */
+	public List<Data> getData(IdCodePair idc) {
+		return data.get(idc);
+	}
+	
+	/**
+	 * Get the first {@link Data} instance of the cached data for this gene-product.
+	 * @param idc The IdCodePair that represents the gene-product for which the data has to be returned
+	 * @return a {@link Data} instance that contains the cached data
+	 */
+	public Data getSingleData(IdCodePair idc) {
+		List<Data> dlist = data.get(idc);
+		if(dlist != null && dlist.size() > 0) return dlist.get(0);
+		return null;
+	}
+	
+	/**
+	 * Add cached data for the given gene-product
+	 * @param idc The IdCodePair that represents the gene-product for which the data has to be added
+	 * @param d The data that has to be added
+	 */
+	protected void addData(IdCodePair idc, Data d) {
+		List<Data> dlist = data.get(idc);
+		if(dlist == null) 
+			data.put(idc, dlist = new ArrayList<Data>());
+		dlist.add(d);
+	}
+	
+	/**
+	 * Get the averaged sample data for the given gene-product
+	 * @param idc The IdCodePair that represents the gene-product to get the data for
+	 * @return a HashMap where the keys represent the sample ids and the values the averaged data
+	 * @see Data#getSampleData()
+	 */
+	public HashMap<Integer, Object> getAverageSampleData(IdCodePair idc)
+	{
+		HashMap<Integer, Object> averageData = new HashMap<Integer, Object>();
+		List<Data> dlist = data.get(idc);
+		if(dlist != null) {
+			HashMap<Integer, Sample> samples = Gex.getSamples();
+			for(int idSample : samples.keySet())
+			{
+				int dataType = samples.get(idSample).getDataType();
+				if(dataType == Types.REAL) {
+					averageData.put(idSample, averageDouble(dlist, idSample));
+				} else {
+					averageData.put(idSample, averageString(dlist, idSample));
+				}
+			}
+		}
+		return averageData;
+	}
+	
+	
+	private Object averageDouble(List<Data> dlist, int idSample)
+	{
+		double avg = 0;
+		int n = 0;
+		for(Data d : dlist) {
+			try { 
+				Double value = (Double)d.getSampleData(idSample);
+				if( !value.isNaN() ) {
+					avg += value;
+					n++;
+				}
+			} catch(Exception e) { }
+		}
+		if(n > 0) {
+			return avg / n;
+		} else {
+			return Double.NaN;
+		}
+	}
+	
+	private Object averageString(List<Data> dlist, int idSample)
+	{
+		StringBuilder sb = new StringBuilder();
+		for(Data d : dlist) {
+			sb.append(d.getSampleData(idSample) + ", ");
+		}
+		int end = sb.lastIndexOf(", ");
+		return end < 0 ? "" : sb.substring(0, end).toString();
+	}
+	
+	/**
+	 * This class represents cached expression data for a reporter in the dataset.
+	 * The data is stored in a {@link HashMap} where the keys are the sample ids and the value
+	 * is an object of class {@link String} or {@link Double} for text and numeric data respectively.
+	 * @author Thomas
+	 */
+	public static class Data {
+		IdCodePair idc;
+		int group;
+		HashMap<Integer, Object> sampleData;
+		
+		/**
+		 * Constructor for this class. Creates a new {@link Data} object for the given reporter
+		 * @param ref The IdCodePair that represents the reporter
+		 * @param groupId An id that groups the expression data from duplicate reporters
+		 */
+		protected Data(IdCodePair ref, int groupId) {
+			idc = ref;
+			group = groupId;
+			sampleData = new HashMap<Integer, Object>();
+		}
+		
+		/**
+		 * Get the reporter this object contains data for
+		 * @return The IdCodePair that represents the reporter this object contains data for
+		 */
+		public IdCodePair getIdCodePair() { return idc; }
+		
+		/**
+		 * Get the group id for this object
+		 * @return a group id that can be used to distinct identical reporters that occur more
+		 * than once in the dataset
+		 */
+		public int getGroup() { return group; }
+		
+		/**
+		 * Get the data for each sample
+		 * @return A {@link HashMap} that contains the data for each sample. The key is a sampleId and value
+		 * is an object of class {@link String} or {@link Double}, depending on the data type of the sample.
+		 * @see Sample#getDataType()
+		 * @see Sample#getId()
+		 */
+		public HashMap<Integer, Object> getSampleData() {
+			return sampleData;
+		}
+		
+		/**
+		 * Get the cached data for the given sample (shortcut for getSampleData().get(sampleId))
+		 * @param sampleId The id of the sample to get the data for
+		 * @return An object of class {@link String} or {@link Double}, depending on the datatype of the sample.
+		 * @see Sample#getDataType()
+		 * @see Sample#getId()
+		 */
+		public Object getSampleData(int sampleId) {
+			return sampleData.get(sampleId);
+		}
+		
+		/**
+		 * Set the data for the given sample. Data will be parsed to double if possible
+		 * @param sampleId The id of the sample to set the data for
+		 * @param data The {@link String} representation of the data to add
+		 * @see Gex#cacheData
+		 */
+		protected void setSampleData(int sampleId, String data) {
+			Object parsedData = null;
+			try { parsedData = Double.parseDouble(data); }
+			catch(Exception e) { parsedData = data; }
+			sampleData.put(sampleId, parsedData);
+		}
+		
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/data/CachedData.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/util/swt/SuggestCombo.java
===================================================================
--- trunk/src/swt/org/pathvisio/util/swt/SuggestCombo.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/util/swt/SuggestCombo.java	(revision 1041)
@@ -14,8 +14,8 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-package org.pathvisio.util.swt;
-
+package org.pathvisio.util.swt;
+
 import java.util.ArrayList;
 
 import org.eclipse.swt.SWT;
@@ -33,325 +33,325 @@
 import org.eclipse.swt.widgets.Shell;
 import org.eclipse.swt.widgets.Text;
 import org.pathvisio.util.swt.SuggestCombo.SuggestionProvider.SuggestThread;
-
-public class SuggestCombo extends Composite {
-	protected boolean ignoreModify;
-	protected boolean ignoreFocusOut;
-
-	private SuggestThread currThread;
-	
-	private java.util.List<SuggestionListener> listeners;
-	private SuggestionProvider suggestionProvider;
-	
-	private int maxHeight = 100;
-	
-	private Text text;
-	private Shell suggestShell;
-	private List suggestList;
-	
-	public SuggestCombo(Composite parent, SuggestionProvider s) {
-		super(parent, SWT.NONE);
-		listeners = new ArrayList<SuggestionListener>();
-		suggestionProvider = s;
-		init(parent);
-	}
-	
-	public Control getControl() { 
-		return text;
-	}
-	
-	public SuggestionProvider getSuggestionProvider() { 
-		return suggestionProvider; 
-	}
-	
-	public boolean isFocusControl() {		
-		return 	text.isVisible() && text.isFocusControl() ||
-				isSuggestFocus();
-	}
-	
-	public boolean isSuggestFocus() {
-		return 	suggestShell.isVisible() && suggestShell.isFocusControl() ||
-				suggestList.isVisible() && suggestList.isFocusControl();
-	}
-	
-	public String getText() {
-		return text.getText();
-	}
-	
-	public void setText(String s) {
-		text.setText(s);
-	}
-	
-	public void setMaxHeight(int height) {
-		maxHeight = height;
-	}
-	
-	public int getMaxHeight() { return maxHeight; }
-	
-	void init(Composite parent) {
-		setLayout(new FillLayout());
-		
-		text = new Text(this, SWT.NONE);
-		Listener textListener = new Listener() {
-			public void handleEvent(Event e) {
-				switch(e.type) {
-				case SWT.Modify:
-					if(!ignoreModify) {
-						startSuggesting();
-						currThread.setText(text.getText());
-					} else {
-//						hideSuggestions();
-						ignoreModify = false;
-					}
-					break;
-				case SWT.KeyDown:
-					if(e.keyCode == SWT.ARROW_DOWN) {
-						if(suggestShell.isVisible()) {
-							suggestList.select(0);
-							suggestList.setFocus();
-						}
-					}
-					break;
-				case SWT.FocusOut:
-					if(!ignoreFocusOut) {
-						//Check if focus is on suggestShell/suggestList
-						if(!isSuggestFocus()) stopSuggesting();
-					}
-					break;
-				}
-			}
-		};
-		
-		text.addListener(SWT.Modify, textListener);
-		text.addListener(SWT.KeyDown, textListener);
-		text.addListener(SWT.FocusOut, textListener);
-
-		suggestShell = new Shell(getShell(), SWT.TOOL | SWT.ON_TOP);
-		suggestShell.setLayout(new FillLayout());
-		suggestList = new List(suggestShell, SWT.SINGLE | SWT.V_SCROLL | SWT.H_SCROLL);
-		
-		Listener listListener = new Listener() {
-			public void handleEvent(Event e) {
-				switch(e.type) {
-				case SWT.KeyDown:
-					if(e.keyCode != 13) break; //TODO:find proper SWT constant for return key
-				case SWT.DefaultSelection:
-				case SWT.MouseDown:
-					String[] selection = suggestList.getSelection();
-					if(selection.length > 0) 
-						suggestionSelected(suggestList.getSelection()[0]);
-					break;
-				case SWT.FocusOut:
-					if(!ignoreFocusOut) {
-						stopSuggesting();
-					}
-				}
-			}
-		};
-		suggestList.addListener(SWT.KeyDown, listListener);
-		suggestList.addListener(SWT.DefaultSelection, listListener);
-		suggestList.addListener(SWT.MouseDown, listListener);
-		suggestList.addListener(SWT.FocusOut, listListener);
-		
-		getShell().addShellListener(new ShellAdapter() {
-			public void shellDeactivated(ShellEvent e) {
-				stopSuggesting();
-			}
-		});
-		suggestShell.addShellListener(new ShellAdapter() {
-			public void shellActivated(ShellEvent arg0) {
-				showSuggestions();
-			}
-		});
-		// DisposeListener, in case user closes PathVisio while suggestShell is still active
-		suggestShell.addDisposeListener(new DisposeListener() {
-			public void widgetDisposed(DisposeEvent e) {
-				stopSuggesting();
-			}
-		});
-	}
-	
-	public void setVisible(boolean visible) {
-		stopSuggesting();
-		super.setVisible(visible);
-	}
-	
-	public void dispose() {
-		super.dispose();
-		suggestShell.dispose();
-	}
-	
-	void startSuggesting() {		
-		if(!suggestShell.isVisible()) {
-			initSuggestShell();
-		}
-		if(!isSuggesting()) {
-			currThread = new SuggestThread(text.getText(), this);
-			currThread.start();
-		}
-	}
-	
-	void stopSuggesting() {
-		doHideSuggestions();
-		if(currThread != null) {
-			currThread.interrupt();
-		}
-		currThread = null;
-	}
-	
-	boolean isSuggesting() {
-		return currThread != null && currThread.getState() != Thread.State.TERMINATED;
-	}
-	
-	public void addSuggestion(final String suggestion) {
-		getDisplay().asyncExec(new Runnable() {
-			public void run() {
-				doAddSuggestion(suggestion);
-			}
-		});
-}
-	
-	void doAddSuggestion(String suggestion) {
-			suggestList.add(suggestion);
-			showSuggestions();
-			resizeSuggestShell();
-	}
-	
-
-	
-	void initSuggestShell() {
-		Point location = text.getLocation();
-		location.y += text.getSize().y;
-		suggestShell.setLocation(text.toDisplay(location));
-		resizeSuggestShell();
-	}
-	
-	void resizeSuggestShell() {
-		Point listSize = suggestList.computeSize(SWT.DEFAULT, SWT.DEFAULT);
-		suggestShell.setSize(listSize.x, listSize.y < maxHeight ? listSize.y : maxHeight);
-	}
-	
-	public void setSuggestions(final String[] suggestions) {
-		getDisplay().asyncExec(new Runnable() {
-			public void run() {
-				doSetSuggestions(suggestions);
-			}
-		});
-	}
-	
-	void doSetSuggestions(String[] suggestions) {
-		suggestList.setItems(suggestions);
-		resizeSuggestShell();
-		showSuggestions();
-	}
-	
-	public void hideSuggestions() {
-		getDisplay().asyncExec(new Runnable() {
-			public void run() {
-				doHideSuggestions();
-			}
-		});
-	}
-	
-	void doHideSuggestions() {
-		if(!suggestShell.isDisposed()) 
-			suggestShell.setVisible(false);
-	}
-	
-	void showSuggestions() {
-		boolean restoreFocus = text.isFocusControl();
-		if(isFocusControl() && suggestList.getItemCount() > 0) {
-			suggestShell.setVisible(true);
-			
-			if(restoreFocus) {
-				ignoreFocusOut = true;
-				text.setFocus();
-				ignoreFocusOut = false;
-			}
-			
-		} else {
-			doHideSuggestions();
-		}
-	}
-	
-	void suggestionSelected(String suggestion) {
-		ignoreModify = true;
-		text.setText(suggestion);
-		doHideSuggestions();
-		for(SuggestionListener l : listeners) {
-			ignoreModify = true;
-			l.suggestionSelected(suggestion);
-		}
-	}
-	
-	public void addSuggetsionListener(SuggestionListener l) {
-		listeners.add(l);
-	}
-	
-	public interface SuggestionProvider {		
-		public String[] getSuggestions(String text, SuggestCombo suggestCombo);
-		
-		public class SuggestThread extends Thread {
-			protected SuggestCombo suggestCombo;
-			volatile protected String text;
-			volatile protected boolean textChange;
-			
-			private Thread doSuggestThread;
-			
-			public SuggestCombo getSuggestCombo() { return suggestCombo; }
-			public String getText() { return text; }
-			
-			public void setText(String newText) { 
-				text = newText;
-				textChange = true;
-			}
-			
-			public SuggestThread(String _text, SuggestCombo _suggestCombo) {
-				text = _text;
-				suggestCombo = _suggestCombo;
-			}
-			
-			public void start() {
-				if(suggestCombo == null || suggestCombo.isDisposed()) return;
-				super.start();
-			}
-
-			void setSuggestions(String[] suggestions) {
-				if(Thread.currentThread() == doSuggestThread) {
-					suggestCombo.setSuggestions(suggestions);
-				}
-			}
-			
-			public void run() {
-				while(!isInterrupted()) {
-					if(textChange) {
-						if(doSuggestThread != null) doSuggestThread.interrupt();
-						suggestCombo.hideSuggestions();
-						if(!text.equals("")) {
-							doSuggestThread = new Thread() {
-								public void run() {
-									SuggestionProvider sp = suggestCombo.getSuggestionProvider();
-									setSuggestions(sp.getSuggestions(text, suggestCombo));
-								}
-							};
-							doSuggestThread.start();
-						} else {
-							suggestCombo.hideSuggestions();
-						}
-						textChange = false;
-					} else {						
-						try {
-							Thread.sleep(300); //Wait for a while, in case user continues typing
-						} catch (InterruptedException e) {
-							return;
-						}
-					}
-				}
-			}
-		}
-	}
-		
-	public interface SuggestionListener {
-		public void suggestionSelected(String suggestion);
-	}
-}
+
+public class SuggestCombo extends Composite {
+	protected boolean ignoreModify;
+	protected boolean ignoreFocusOut;
+
+	private SuggestThread currThread;
+	
+	private java.util.List<SuggestionListener> listeners;
+	private SuggestionProvider suggestionProvider;
+	
+	private int maxHeight = 100;
+	
+	private Text text;
+	private Shell suggestShell;
+	private List suggestList;
+	
+	public SuggestCombo(Composite parent, SuggestionProvider s) {
+		super(parent, SWT.NONE);
+		listeners = new ArrayList<SuggestionListener>();
+		suggestionProvider = s;
+		init(parent);
+	}
+	
+	public Control getControl() { 
+		return text;
+	}
+	
+	public SuggestionProvider getSuggestionProvider() { 
+		return suggestionProvider; 
+	}
+	
+	public boolean isFocusControl() {		
+		return 	text.isVisible() && text.isFocusControl() ||
+				isSuggestFocus();
+	}
+	
+	public boolean isSuggestFocus() {
+		return 	suggestShell.isVisible() && suggestShell.isFocusControl() ||
+				suggestList.isVisible() && suggestList.isFocusControl();
+	}
+	
+	public String getText() {
+		return text.getText();
+	}
+	
+	public void setText(String s) {
+		text.setText(s);
+	}
+	
+	public void setMaxHeight(int height) {
+		maxHeight = height;
+	}
+	
+	public int getMaxHeight() { return maxHeight; }
+	
+	void init(Composite parent) {
+		setLayout(new FillLayout());
+		
+		text = new Text(this, SWT.NONE);
+		Listener textListener = new Listener() {
+			public void handleEvent(Event e) {
+				switch(e.type) {
+				case SWT.Modify:
+					if(!ignoreModify) {
+						startSuggesting();
+						currThread.setText(text.getText());
+					} else {
+//						hideSuggestions();
+						ignoreModify = false;
+					}
+					break;
+				case SWT.KeyDown:
+					if(e.keyCode == SWT.ARROW_DOWN) {
+						if(suggestShell.isVisible()) {
+							suggestList.select(0);
+							suggestList.setFocus();
+						}
+					}
+					break;
+				case SWT.FocusOut:
+					if(!ignoreFocusOut) {
+						//Check if focus is on suggestShell/suggestList
+						if(!isSuggestFocus()) stopSuggesting();
+					}
+					break;
+				}
+			}
+		};
+		
+		text.addListener(SWT.Modify, textListener);
+		text.addListener(SWT.KeyDown, textListener);
+		text.addListener(SWT.FocusOut, textListener);
+
+		suggestShell = new Shell(getShell(), SWT.TOOL | SWT.ON_TOP);
+		suggestShell.setLayout(new FillLayout());
+		suggestList = new List(suggestShell, SWT.SINGLE | SWT.V_SCROLL | SWT.H_SCROLL);
+		
+		Listener listListener = new Listener() {
+			public void handleEvent(Event e) {
+				switch(e.type) {
+				case SWT.KeyDown:
+					if(e.keyCode != 13) break; //TODO:find proper SWT constant for return key
+				case SWT.DefaultSelection:
+				case SWT.MouseDown:
+					String[] selection = suggestList.getSelection();
+					if(selection.length > 0) 
+						suggestionSelected(suggestList.getSelection()[0]);
+					break;
+				case SWT.FocusOut:
+					if(!ignoreFocusOut) {
+						stopSuggesting();
+					}
+				}
+			}
+		};
+		suggestList.addListener(SWT.KeyDown, listListener);
+		suggestList.addListener(SWT.DefaultSelection, listListener);
+		suggestList.addListener(SWT.MouseDown, listListener);
+		suggestList.addListener(SWT.FocusOut, listListener);
+		
+		getShell().addShellListener(new ShellAdapter() {
+			public void shellDeactivated(ShellEvent e) {
+				stopSuggesting();
+			}
+		});
+		suggestShell.addShellListener(new ShellAdapter() {
+			public void shellActivated(ShellEvent arg0) {
+				showSuggestions();
+			}
+		});
+		// DisposeListener, in case user closes PathVisio while suggestShell is still active
+		suggestShell.addDisposeListener(new DisposeListener() {
+			public void widgetDisposed(DisposeEvent e) {
+				stopSuggesting();
+			}
+		});
+	}
+	
+	public void setVisible(boolean visible) {
+		stopSuggesting();
+		super.setVisible(visible);
+	}
+	
+	public void dispose() {
+		super.dispose();
+		suggestShell.dispose();
+	}
+	
+	void startSuggesting() {		
+		if(!suggestShell.isVisible()) {
+			initSuggestShell();
+		}
+		if(!isSuggesting()) {
+			currThread = new SuggestThread(text.getText(), this);
+			currThread.start();
+		}
+	}
+	
+	void stopSuggesting() {
+		doHideSuggestions();
+		if(currThread != null) {
+			currThread.interrupt();
+		}
+		currThread = null;
+	}
+	
+	boolean isSuggesting() {
+		return currThread != null && currThread.getState() != Thread.State.TERMINATED;
+	}
+	
+	public void addSuggestion(final String suggestion) {
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				doAddSuggestion(suggestion);
+			}
+		});
+}
+	
+	void doAddSuggestion(String suggestion) {
+			suggestList.add(suggestion);
+			showSuggestions();
+			resizeSuggestShell();
+	}
+	
+
+	
+	void initSuggestShell() {
+		Point location = text.getLocation();
+		location.y += text.getSize().y;
+		suggestShell.setLocation(text.toDisplay(location));
+		resizeSuggestShell();
+	}
+	
+	void resizeSuggestShell() {
+		Point listSize = suggestList.computeSize(SWT.DEFAULT, SWT.DEFAULT);
+		suggestShell.setSize(listSize.x, listSize.y < maxHeight ? listSize.y : maxHeight);
+	}
+	
+	public void setSuggestions(final String[] suggestions) {
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				doSetSuggestions(suggestions);
+			}
+		});
+	}
+	
+	void doSetSuggestions(String[] suggestions) {
+		suggestList.setItems(suggestions);
+		resizeSuggestShell();
+		showSuggestions();
+	}
+	
+	public void hideSuggestions() {
+		getDisplay().asyncExec(new Runnable() {
+			public void run() {
+				doHideSuggestions();
+			}
+		});
+	}
+	
+	void doHideSuggestions() {
+		if(!suggestShell.isDisposed()) 
+			suggestShell.setVisible(false);
+	}
+	
+	void showSuggestions() {
+		boolean restoreFocus = text.isFocusControl();
+		if(isFocusControl() && suggestList.getItemCount() > 0) {
+			suggestShell.setVisible(true);
+			
+			if(restoreFocus) {
+				ignoreFocusOut = true;
+				text.setFocus();
+				ignoreFocusOut = false;
+			}
+			
+		} else {
+			doHideSuggestions();
+		}
+	}
+	
+	void suggestionSelected(String suggestion) {
+		ignoreModify = true;
+		text.setText(suggestion);
+		doHideSuggestions();
+		for(SuggestionListener l : listeners) {
+			ignoreModify = true;
+			l.suggestionSelected(suggestion);
+		}
+	}
+	
+	public void addSuggetsionListener(SuggestionListener l) {
+		listeners.add(l);
+	}
+	
+	public interface SuggestionProvider {		
+		public String[] getSuggestions(String text, SuggestCombo suggestCombo);
+		
+		public class SuggestThread extends Thread {
+			protected SuggestCombo suggestCombo;
+			volatile protected String text;
+			volatile protected boolean textChange;
+			
+			private Thread doSuggestThread;
+			
+			public SuggestCombo getSuggestCombo() { return suggestCombo; }
+			public String getText() { return text; }
+			
+			public void setText(String newText) { 
+				text = newText;
+				textChange = true;
+			}
+			
+			public SuggestThread(String _text, SuggestCombo _suggestCombo) {
+				text = _text;
+				suggestCombo = _suggestCombo;
+			}
+			
+			public void start() {
+				if(suggestCombo == null || suggestCombo.isDisposed()) return;
+				super.start();
+			}
+
+			void setSuggestions(String[] suggestions) {
+				if(Thread.currentThread() == doSuggestThread) {
+					suggestCombo.setSuggestions(suggestions);
+				}
+			}
+			
+			public void run() {
+				while(!isInterrupted()) {
+					if(textChange) {
+						if(doSuggestThread != null) doSuggestThread.interrupt();
+						suggestCombo.hideSuggestions();
+						if(!text.equals("")) {
+							doSuggestThread = new Thread() {
+								public void run() {
+									SuggestionProvider sp = suggestCombo.getSuggestionProvider();
+									setSuggestions(sp.getSuggestions(text, suggestCombo));
+								}
+							};
+							doSuggestThread.start();
+						} else {
+							suggestCombo.hideSuggestions();
+						}
+						textChange = false;
+					} else {						
+						try {
+							Thread.sleep(300); //Wait for a while, in case user continues typing
+						} catch (InterruptedException e) {
+							return;
+						}
+					}
+				}
+			}
+		}
+	}
+		
+	public interface SuggestionListener {
+		public void suggestionSelected(String suggestion);
+	}
+}

Property changes on: trunk/src/swt/org/pathvisio/util/swt/SuggestCombo.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: trunk/src/swt/org/pathvisio/util/swt/SuggestCellEditor.java
===================================================================
--- trunk/src/swt/org/pathvisio/util/swt/SuggestCellEditor.java	(revision 1040)
+++ trunk/src/swt/org/pathvisio/util/swt/SuggestCellEditor.java	(revision 1041)
@@ -14,8 +14,8 @@
 // See the License for the specific language governing permissions and 
 // limitations under the License.
 //
-package org.pathvisio.util.swt;
-
+package org.pathvisio.util.swt;
+
 import org.eclipse.jface.viewers.CellEditor;
 import org.eclipse.swt.events.FocusAdapter;
 import org.eclipse.swt.events.FocusEvent;
@@ -24,55 +24,55 @@
 import org.eclipse.swt.widgets.Composite;
 import org.eclipse.swt.widgets.Control;
 import org.pathvisio.util.swt.SuggestCombo.SuggestionProvider;
-
-public abstract class SuggestCellEditor extends CellEditor {
-	protected SuggestCombo suggestCombo;
-	
-	public SuggestCellEditor() {
-		super();
-	}
-	
-	public SuggestCellEditor(Composite parent) {
-		super(parent);
-	}
-		
-	protected Control createControl(Composite parent) {
-		suggestCombo = new SuggestCombo(parent, getSuggestionProvider());
-
-		setKeyListeners();
-		setFocusListeners();
-
-		return suggestCombo;
-	}
-
-	protected void setKeyListeners() {
-		suggestCombo.getControl().addKeyListener(new KeyAdapter() {
-            public void keyPressed(KeyEvent e) {
-                keyReleaseOccured(e);
-            }
-		});
-	}
-	
-	protected void setFocusListeners() {
-        suggestCombo.getControl().addFocusListener(new FocusAdapter() {
-            public void focusLost(FocusEvent e) {
-            	if(!suggestCombo.isSuggestFocus()) {
-            		SuggestCellEditor.this.focusLost();
-            	}
-            }
-        });
-	}
-	public abstract SuggestionProvider getSuggestionProvider();
-		
-	protected Object doGetValue() {
-		return suggestCombo.getText();
-	}
-	
-	protected void doSetValue(Object value) {
-		suggestCombo.setText(value == null ? "" : value.toString());
-	}
-
-	protected void doSetFocus() {}
-
-
-}
+
+public abstract class SuggestCellEditor extends CellEditor {
+	protected SuggestCombo suggestCombo;
+	
+	public SuggestCellEditor() {
+		super();
+	}
+	
+	public SuggestCellEditor(Composite parent) {
+		super(parent);
+	}
+		
+	protected Control createControl(Composite parent) {
+		suggestCombo = new SuggestCombo(parent, getSuggestionProvider());
+
+		setKeyListeners();
+		setFocusListeners();
+
+		return suggestCombo;
+	}
+
+	protected void setKeyListeners() {
+		suggestCombo.getControl().addKeyListener(new KeyAdapter() {
+            public void keyPressed(KeyEvent e) {
+                keyReleaseOccured(e);
+            }
+		});
+	}
+	
+	protected void setFocusListeners() {
+        suggestCombo.getControl().addFocusListener(new FocusAdapter() {
+            public void focusLost(FocusEvent e) {
+            	if(!suggestCombo.isSuggestFocus()) {
+            		SuggestCellEditor.this.focusLost();
+            	}
+            }
+        });
+	}
+	public abstract SuggestionProvider getSuggestionProvider();
+		
+	protected Object doGetValue() {
+		return suggestCombo.getText();
+	}
+	
+	protected void doSetValue(Object value) {
+		suggestCombo.setText(value == null ? "" : value.toString());
+	}
+
+	protected void doSetFocus() {}
+
+
+}

Property changes on: trunk/src/swt/org/pathvisio/util/swt/SuggestCellEditor.java
___________________________________________________________________
Name: svn:eol-style
   + native

